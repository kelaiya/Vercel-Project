{"ast":null,"code":"/* global WeakRef */\n\nexport const privateProps = new WeakMap();\nexport class InvalidStateError extends Error {}\nexport class NotSupportedError extends Error {}\nexport class NotFoundError extends Error {}\nconst HLS_RESPONSE_HEADERS = ['application/x-mpegURL', 'application/vnd.apple.mpegurl', 'audio/mpegurl'];\n\n// Fallback to a plain Set if WeakRef is not available.\nexport const IterableWeakSet = globalThis.WeakRef ? class extends Set {\n  add(el) {\n    super.add(new WeakRef(el));\n  }\n  forEach(fn) {\n    super.forEach(ref => {\n      const value = ref.deref();\n      if (value) fn(value);\n    });\n  }\n} : Set;\nexport function onCastApiAvailable(callback) {\n  if (!globalThis.chrome?.cast?.isAvailable) {\n    globalThis.__onGCastApiAvailable = () => {\n      // The globalThis.__onGCastApiAvailable callback alone is not reliable for\n      // the added cast.framework. It's loaded in a separate JS file.\n      // https://www.gstatic.com/eureka/clank/101/cast_sender.js\n      // https://www.gstatic.com/cast/sdk/libs/sender/1.0/cast_framework.js\n      customElements.whenDefined('google-cast-button').then(callback);\n    };\n  } else if (!globalThis.cast?.framework) {\n    customElements.whenDefined('google-cast-button').then(callback);\n  } else {\n    callback();\n  }\n}\nexport function requiresCastFramework() {\n  // todo: exclude for Android>=56 which supports the Remote Playback API natively.\n  return globalThis.chrome;\n}\nexport function loadCastFramework() {\n  const sdkUrl = 'https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1';\n  if (globalThis.chrome?.cast || document.querySelector(`script[src=\"${sdkUrl}\"]`)) return;\n  const script = document.createElement('script');\n  script.src = sdkUrl;\n  document.head.append(script);\n}\nexport function castContext() {\n  return globalThis.cast?.framework?.CastContext.getInstance();\n}\nexport function currentSession() {\n  return castContext()?.getCurrentSession();\n}\nexport function currentMedia() {\n  return currentSession()?.getSessionObj().media[0];\n}\nexport function editTracksInfo(request) {\n  return new Promise((resolve, reject) => {\n    currentMedia().editTracksInfo(request, resolve, reject);\n  });\n}\nexport function getMediaStatus(request) {\n  return new Promise((resolve, reject) => {\n    currentMedia().getStatus(request, resolve, reject);\n  });\n}\nexport function setCastOptions(options) {\n  return castContext().setOptions({\n    ...getDefaultCastOptions(),\n    ...options\n  });\n}\nexport function getDefaultCastOptions() {\n  return {\n    // Set the receiver application ID to your own (created in the\n    // Google Cast Developer Console), or optionally\n    // use the chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID\n    receiverApplicationId: 'CC1AD845',\n    // Auto join policy can be one of the following three:\n    // ORIGIN_SCOPED - Auto connect from same appId and page origin\n    // TAB_AND_ORIGIN_SCOPED - Auto connect from same appId, page origin, and tab\n    // PAGE_SCOPED - No auto connect\n    autoJoinPolicy: 'origin_scoped',\n    // The following flag enables Cast Connect(requires Chrome 87 or higher)\n    // https://developers.googleblog.com/2020/08/introducing-cast-connect-android-tv.html\n    androidReceiverCompatible: false,\n    language: 'en-US',\n    resumeSavedSession: true\n  };\n}\n\n//Get the segment format given the end of the URL (.m4s, .ts, etc)\nfunction getFormat(segment) {\n  if (!segment) return undefined;\n  const regex = /\\.([a-zA-Z0-9]+)(?:\\?.*)?$/;\n  const match = segment.match(regex);\n  return match ? match[1] : null;\n}\nfunction parsePlaylistUrls(playlistContent) {\n  const lines = playlistContent.split('\\n');\n  const urls = [];\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n\n    // Locate available video playlists and get the next line which is the URI (https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-17#section-4.4.6.2)\n    if (line.startsWith('#EXT-X-STREAM-INF')) {\n      const nextLine = lines[i + 1] ? lines[i + 1].trim() : '';\n      if (nextLine && !nextLine.startsWith('#')) {\n        urls.push(nextLine);\n      }\n    }\n  }\n  return urls;\n}\nfunction parseSegment(playlistContent) {\n  const lines = playlistContent.split('\\n');\n  const url = lines.find(line => !line.trim().startsWith('#') && line.trim() !== '');\n  return url;\n}\nexport async function isHls(url) {\n  try {\n    const response = await fetch(url, {\n      method: 'HEAD'\n    });\n    const contentType = response.headers.get('Content-Type');\n    return HLS_RESPONSE_HEADERS.some(header => contentType === header);\n  } catch (err) {\n    console.error('Error while trying to get the Content-Type of the manifest', err);\n    return false;\n  }\n}\nexport async function getPlaylistSegmentFormat(url) {\n  try {\n    const mainManifestContent = await (await fetch(url)).text();\n    let availableChunksContent = mainManifestContent;\n    const playlists = parsePlaylistUrls(mainManifestContent);\n    if (playlists.length > 0) {\n      const chosenPlaylistUrl = new URL(playlists[0], url).toString();\n      availableChunksContent = await (await fetch(chosenPlaylistUrl)).text();\n    }\n    const segment = parseSegment(availableChunksContent);\n    const format = getFormat(segment);\n    return format;\n  } catch (err) {\n    console.error('Error while trying to parse the manifest playlist', err);\n    return undefined;\n  }\n}","map":{"version":3,"names":["privateProps","WeakMap","InvalidStateError","Error","NotSupportedError","NotFoundError","HLS_RESPONSE_HEADERS","IterableWeakSet","globalThis","WeakRef","Set","add","el","forEach","fn","ref","value","deref","onCastApiAvailable","callback","chrome","cast","isAvailable","__onGCastApiAvailable","customElements","whenDefined","then","framework","requiresCastFramework","loadCastFramework","sdkUrl","document","querySelector","script","createElement","src","head","append","castContext","CastContext","getInstance","currentSession","getCurrentSession","currentMedia","getSessionObj","media","editTracksInfo","request","Promise","resolve","reject","getMediaStatus","getStatus","setCastOptions","options","setOptions","getDefaultCastOptions","receiverApplicationId","autoJoinPolicy","androidReceiverCompatible","language","resumeSavedSession","getFormat","segment","undefined","regex","match","parsePlaylistUrls","playlistContent","lines","split","urls","i","length","line","trim","startsWith","nextLine","push","parseSegment","url","find","isHls","response","fetch","method","contentType","headers","get","some","header","err","console","error","getPlaylistSegmentFormat","mainManifestContent","text","availableChunksContent","playlists","chosenPlaylistUrl","URL","toString","format"],"sources":["/Users/kelaiyaparikh/projects/first-app/client/node_modules/castable-video/castable-utils.js"],"sourcesContent":["/* global WeakRef */\n\nexport const privateProps = new WeakMap();\n\nexport class InvalidStateError extends Error {}\nexport class NotSupportedError extends Error {}\nexport class NotFoundError extends Error {}\n\nconst HLS_RESPONSE_HEADERS = ['application/x-mpegURL','application/vnd.apple.mpegurl','audio/mpegurl']\n\n// Fallback to a plain Set if WeakRef is not available.\nexport const IterableWeakSet = globalThis.WeakRef ?\n  class extends Set {\n    add(el) {\n      super.add(new WeakRef(el));\n    }\n    forEach(fn) {\n      super.forEach((ref) => {\n        const value = ref.deref();\n        if (value) fn(value);\n      });\n    }\n  } : Set;\n\nexport function onCastApiAvailable(callback) {\n  if (!globalThis.chrome?.cast?.isAvailable) {\n    globalThis.__onGCastApiAvailable = () => {\n      // The globalThis.__onGCastApiAvailable callback alone is not reliable for\n      // the added cast.framework. It's loaded in a separate JS file.\n      // https://www.gstatic.com/eureka/clank/101/cast_sender.js\n      // https://www.gstatic.com/cast/sdk/libs/sender/1.0/cast_framework.js\n      customElements\n        .whenDefined('google-cast-button')\n        .then(callback);\n    };\n  } else if (!globalThis.cast?.framework) {\n    customElements\n      .whenDefined('google-cast-button')\n      .then(callback);\n  } else {\n    callback();\n  }\n}\n\nexport function requiresCastFramework() {\n  // todo: exclude for Android>=56 which supports the Remote Playback API natively.\n  return globalThis.chrome;\n}\n\nexport function loadCastFramework() {\n  const sdkUrl = 'https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1';\n  if (globalThis.chrome?.cast || document.querySelector(`script[src=\"${sdkUrl}\"]`)) return;\n\n  const script = document.createElement('script');\n  script.src = sdkUrl;\n  document.head.append(script);\n}\n\nexport function castContext() {\n  return globalThis.cast?.framework?.CastContext.getInstance();\n}\n\nexport function currentSession() {\n  return castContext()?.getCurrentSession();\n}\n\nexport function currentMedia() {\n  return currentSession()?.getSessionObj().media[0];\n}\n\nexport function editTracksInfo(request) {\n  return new Promise((resolve, reject) => {\n    currentMedia().editTracksInfo(request, resolve, reject);\n  });\n}\n\nexport function getMediaStatus(request) {\n  return new Promise((resolve, reject) => {\n    currentMedia().getStatus(request, resolve, reject);\n  });\n}\n\nexport function setCastOptions(options) {\n  return castContext().setOptions({\n    ...getDefaultCastOptions(),\n    ...options,\n  });\n}\n\nexport function getDefaultCastOptions() {\n  return {\n    // Set the receiver application ID to your own (created in the\n    // Google Cast Developer Console), or optionally\n    // use the chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID\n    receiverApplicationId: 'CC1AD845',\n\n    // Auto join policy can be one of the following three:\n    // ORIGIN_SCOPED - Auto connect from same appId and page origin\n    // TAB_AND_ORIGIN_SCOPED - Auto connect from same appId, page origin, and tab\n    // PAGE_SCOPED - No auto connect\n    autoJoinPolicy: 'origin_scoped',\n\n    // The following flag enables Cast Connect(requires Chrome 87 or higher)\n    // https://developers.googleblog.com/2020/08/introducing-cast-connect-android-tv.html\n    androidReceiverCompatible: false,\n\n    language: 'en-US',\n    resumeSavedSession: true,\n  };\n}\n\n//Get the segment format given the end of the URL (.m4s, .ts, etc)\nfunction getFormat(segment) {\n  if (!segment) return undefined;\n\n  const regex = /\\.([a-zA-Z0-9]+)(?:\\?.*)?$/;\n  const match = segment.match(regex);\n  return match ? match[1] : null;\n}\n\nfunction parsePlaylistUrls(playlistContent) {\n  const lines = playlistContent.split('\\n');\n  const urls = [];\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n\n    // Locate available video playlists and get the next line which is the URI (https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-17#section-4.4.6.2)\n    if (line.startsWith('#EXT-X-STREAM-INF')) {\n      const nextLine = lines[i + 1] ? lines[i + 1].trim() : '';\n      if (nextLine && !nextLine.startsWith('#')) {\n        urls.push(nextLine);\n      }\n    }\n  }\n\n  return urls;\n}\n\nfunction parseSegment(playlistContent){\n  const lines = playlistContent.split('\\n');\n\n  const url = lines.find(line => !line.trim().startsWith('#') && line.trim() !== '');\n\n  return url;\n}\n\nexport async function isHls(url) {\n  try {\n    const response = await fetch(url, {method: 'HEAD'});\n    const contentType = response.headers.get('Content-Type');\n\n    return HLS_RESPONSE_HEADERS.some((header) => contentType === header);\n  } catch (err) {\n    console.error('Error while trying to get the Content-Type of the manifest', err);\n    return false;\n  }\n}\n\nexport async function getPlaylistSegmentFormat(url) {\n  try {\n    const mainManifestContent = await (await fetch(url)).text();\n    let availableChunksContent = mainManifestContent;\n\n    const playlists = parsePlaylistUrls(mainManifestContent);\n    if (playlists.length > 0) {    \n      const chosenPlaylistUrl = new URL(playlists[0], url).toString();\n      availableChunksContent = await (await fetch(chosenPlaylistUrl)).text();\n    }\n\n    const segment = parseSegment(availableChunksContent);\n    const format = getFormat(segment);\n    return format\n  } catch (err) {\n    console.error('Error while trying to parse the manifest playlist', err);\n    return undefined;\n  }\n}"],"mappings":"AAAA;;AAEA,OAAO,MAAMA,YAAY,GAAG,IAAIC,OAAO,CAAC,CAAC;AAEzC,OAAO,MAAMC,iBAAiB,SAASC,KAAK,CAAC;AAC7C,OAAO,MAAMC,iBAAiB,SAASD,KAAK,CAAC;AAC7C,OAAO,MAAME,aAAa,SAASF,KAAK,CAAC;AAEzC,MAAMG,oBAAoB,GAAG,CAAC,uBAAuB,EAAC,+BAA+B,EAAC,eAAe,CAAC;;AAEtG;AACA,OAAO,MAAMC,eAAe,GAAGC,UAAU,CAACC,OAAO,GAC/C,cAAcC,GAAG,CAAC;EAChBC,GAAGA,CAACC,EAAE,EAAE;IACN,KAAK,CAACD,GAAG,CAAC,IAAIF,OAAO,CAACG,EAAE,CAAC,CAAC;EAC5B;EACAC,OAAOA,CAACC,EAAE,EAAE;IACV,KAAK,CAACD,OAAO,CAAEE,GAAG,IAAK;MACrB,MAAMC,KAAK,GAAGD,GAAG,CAACE,KAAK,CAAC,CAAC;MACzB,IAAID,KAAK,EAAEF,EAAE,CAACE,KAAK,CAAC;IACtB,CAAC,CAAC;EACJ;AACF,CAAC,GAAGN,GAAG;AAET,OAAO,SAASQ,kBAAkBA,CAACC,QAAQ,EAAE;EAC3C,IAAI,CAACX,UAAU,CAACY,MAAM,EAAEC,IAAI,EAAEC,WAAW,EAAE;IACzCd,UAAU,CAACe,qBAAqB,GAAG,MAAM;MACvC;MACA;MACA;MACA;MACAC,cAAc,CACXC,WAAW,CAAC,oBAAoB,CAAC,CACjCC,IAAI,CAACP,QAAQ,CAAC;IACnB,CAAC;EACH,CAAC,MAAM,IAAI,CAACX,UAAU,CAACa,IAAI,EAAEM,SAAS,EAAE;IACtCH,cAAc,CACXC,WAAW,CAAC,oBAAoB,CAAC,CACjCC,IAAI,CAACP,QAAQ,CAAC;EACnB,CAAC,MAAM;IACLA,QAAQ,CAAC,CAAC;EACZ;AACF;AAEA,OAAO,SAASS,qBAAqBA,CAAA,EAAG;EACtC;EACA,OAAOpB,UAAU,CAACY,MAAM;AAC1B;AAEA,OAAO,SAASS,iBAAiBA,CAAA,EAAG;EAClC,MAAMC,MAAM,GAAG,4EAA4E;EAC3F,IAAItB,UAAU,CAACY,MAAM,EAAEC,IAAI,IAAIU,QAAQ,CAACC,aAAa,CAAC,eAAeF,MAAM,IAAI,CAAC,EAAE;EAElF,MAAMG,MAAM,GAAGF,QAAQ,CAACG,aAAa,CAAC,QAAQ,CAAC;EAC/CD,MAAM,CAACE,GAAG,GAAGL,MAAM;EACnBC,QAAQ,CAACK,IAAI,CAACC,MAAM,CAACJ,MAAM,CAAC;AAC9B;AAEA,OAAO,SAASK,WAAWA,CAAA,EAAG;EAC5B,OAAO9B,UAAU,CAACa,IAAI,EAAEM,SAAS,EAAEY,WAAW,CAACC,WAAW,CAAC,CAAC;AAC9D;AAEA,OAAO,SAASC,cAAcA,CAAA,EAAG;EAC/B,OAAOH,WAAW,CAAC,CAAC,EAAEI,iBAAiB,CAAC,CAAC;AAC3C;AAEA,OAAO,SAASC,YAAYA,CAAA,EAAG;EAC7B,OAAOF,cAAc,CAAC,CAAC,EAAEG,aAAa,CAAC,CAAC,CAACC,KAAK,CAAC,CAAC,CAAC;AACnD;AAEA,OAAO,SAASC,cAAcA,CAACC,OAAO,EAAE;EACtC,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACtCP,YAAY,CAAC,CAAC,CAACG,cAAc,CAACC,OAAO,EAAEE,OAAO,EAAEC,MAAM,CAAC;EACzD,CAAC,CAAC;AACJ;AAEA,OAAO,SAASC,cAAcA,CAACJ,OAAO,EAAE;EACtC,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;IACtCP,YAAY,CAAC,CAAC,CAACS,SAAS,CAACL,OAAO,EAAEE,OAAO,EAAEC,MAAM,CAAC;EACpD,CAAC,CAAC;AACJ;AAEA,OAAO,SAASG,cAAcA,CAACC,OAAO,EAAE;EACtC,OAAOhB,WAAW,CAAC,CAAC,CAACiB,UAAU,CAAC;IAC9B,GAAGC,qBAAqB,CAAC,CAAC;IAC1B,GAAGF;EACL,CAAC,CAAC;AACJ;AAEA,OAAO,SAASE,qBAAqBA,CAAA,EAAG;EACtC,OAAO;IACL;IACA;IACA;IACAC,qBAAqB,EAAE,UAAU;IAEjC;IACA;IACA;IACA;IACAC,cAAc,EAAE,eAAe;IAE/B;IACA;IACAC,yBAAyB,EAAE,KAAK;IAEhCC,QAAQ,EAAE,OAAO;IACjBC,kBAAkB,EAAE;EACtB,CAAC;AACH;;AAEA;AACA,SAASC,SAASA,CAACC,OAAO,EAAE;EAC1B,IAAI,CAACA,OAAO,EAAE,OAAOC,SAAS;EAE9B,MAAMC,KAAK,GAAG,4BAA4B;EAC1C,MAAMC,KAAK,GAAGH,OAAO,CAACG,KAAK,CAACD,KAAK,CAAC;EAClC,OAAOC,KAAK,GAAGA,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI;AAChC;AAEA,SAASC,iBAAiBA,CAACC,eAAe,EAAE;EAC1C,MAAMC,KAAK,GAAGD,eAAe,CAACE,KAAK,CAAC,IAAI,CAAC;EACzC,MAAMC,IAAI,GAAG,EAAE;EAEf,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,KAAK,CAACI,MAAM,EAAED,CAAC,EAAE,EAAE;IACrC,MAAME,IAAI,GAAGL,KAAK,CAACG,CAAC,CAAC,CAACG,IAAI,CAAC,CAAC;;IAE5B;IACA,IAAID,IAAI,CAACE,UAAU,CAAC,mBAAmB,CAAC,EAAE;MACxC,MAAMC,QAAQ,GAAGR,KAAK,CAACG,CAAC,GAAG,CAAC,CAAC,GAAGH,KAAK,CAACG,CAAC,GAAG,CAAC,CAAC,CAACG,IAAI,CAAC,CAAC,GAAG,EAAE;MACxD,IAAIE,QAAQ,IAAI,CAACA,QAAQ,CAACD,UAAU,CAAC,GAAG,CAAC,EAAE;QACzCL,IAAI,CAACO,IAAI,CAACD,QAAQ,CAAC;MACrB;IACF;EACF;EAEA,OAAON,IAAI;AACb;AAEA,SAASQ,YAAYA,CAACX,eAAe,EAAC;EACpC,MAAMC,KAAK,GAAGD,eAAe,CAACE,KAAK,CAAC,IAAI,CAAC;EAEzC,MAAMU,GAAG,GAAGX,KAAK,CAACY,IAAI,CAACP,IAAI,IAAI,CAACA,IAAI,CAACC,IAAI,CAAC,CAAC,CAACC,UAAU,CAAC,GAAG,CAAC,IAAIF,IAAI,CAACC,IAAI,CAAC,CAAC,KAAK,EAAE,CAAC;EAElF,OAAOK,GAAG;AACZ;AAEA,OAAO,eAAeE,KAAKA,CAACF,GAAG,EAAE;EAC/B,IAAI;IACF,MAAMG,QAAQ,GAAG,MAAMC,KAAK,CAACJ,GAAG,EAAE;MAACK,MAAM,EAAE;IAAM,CAAC,CAAC;IACnD,MAAMC,WAAW,GAAGH,QAAQ,CAACI,OAAO,CAACC,GAAG,CAAC,cAAc,CAAC;IAExD,OAAOlF,oBAAoB,CAACmF,IAAI,CAAEC,MAAM,IAAKJ,WAAW,KAAKI,MAAM,CAAC;EACtE,CAAC,CAAC,OAAOC,GAAG,EAAE;IACZC,OAAO,CAACC,KAAK,CAAC,4DAA4D,EAAEF,GAAG,CAAC;IAChF,OAAO,KAAK;EACd;AACF;AAEA,OAAO,eAAeG,wBAAwBA,CAACd,GAAG,EAAE;EAClD,IAAI;IACF,MAAMe,mBAAmB,GAAG,MAAM,CAAC,MAAMX,KAAK,CAACJ,GAAG,CAAC,EAAEgB,IAAI,CAAC,CAAC;IAC3D,IAAIC,sBAAsB,GAAGF,mBAAmB;IAEhD,MAAMG,SAAS,GAAG/B,iBAAiB,CAAC4B,mBAAmB,CAAC;IACxD,IAAIG,SAAS,CAACzB,MAAM,GAAG,CAAC,EAAE;MACxB,MAAM0B,iBAAiB,GAAG,IAAIC,GAAG,CAACF,SAAS,CAAC,CAAC,CAAC,EAAElB,GAAG,CAAC,CAACqB,QAAQ,CAAC,CAAC;MAC/DJ,sBAAsB,GAAG,MAAM,CAAC,MAAMb,KAAK,CAACe,iBAAiB,CAAC,EAAEH,IAAI,CAAC,CAAC;IACxE;IAEA,MAAMjC,OAAO,GAAGgB,YAAY,CAACkB,sBAAsB,CAAC;IACpD,MAAMK,MAAM,GAAGxC,SAAS,CAACC,OAAO,CAAC;IACjC,OAAOuC,MAAM;EACf,CAAC,CAAC,OAAOX,GAAG,EAAE;IACZC,OAAO,CAACC,KAAK,CAAC,mDAAmD,EAAEF,GAAG,CAAC;IACvE,OAAO3B,SAAS;EAClB;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}