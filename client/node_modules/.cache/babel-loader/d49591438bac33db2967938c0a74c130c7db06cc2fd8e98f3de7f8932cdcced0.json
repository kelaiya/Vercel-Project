{"ast":null,"code":"import { document, globalThis } from \"../utils/server-safe-globals.js\";\nimport { AvailabilityStates, StreamTypes, TextTrackKinds } from \"../constants.js\";\nimport { containsComposedNode } from \"../utils/element-utils.js\";\nimport { enterFullscreen, exitFullscreen, isFullscreen } from \"../utils/fullscreen-api.js\";\nimport { airplaySupported, castSupported, fullscreenSupported, hasFullscreenSupport, hasPipSupport, hasVolumeSupportAsync, pipSupported } from \"../utils/platform-tests.js\";\nimport { getShowingSubtitleTracks, getSubtitleTracks, toggleSubtitleTracks } from \"./util.js\";\nimport { getTextTracksList } from \"../utils/captions.js\";\nimport { isValidNumber } from \"../utils/utils.js\";\nconst StreamTypeValues = Object.values(StreamTypes);\nlet volumeSupported;\nconst volumeSupportPromise = hasVolumeSupportAsync().then(supported => {\n  volumeSupported = supported;\n  return volumeSupported;\n});\nconst prepareStateOwners = async (...stateOwners) => {\n  await Promise.all(stateOwners.filter(x => x).map(async stateOwner => {\n    if (!(\"localName\" in stateOwner && stateOwner instanceof globalThis.HTMLElement)) {\n      return;\n    }\n    const name = stateOwner.localName;\n    if (!name.includes(\"-\")) return;\n    const classDef = globalThis.customElements.get(name);\n    if (classDef && stateOwner instanceof classDef) return;\n    await globalThis.customElements.whenDefined(name);\n    globalThis.customElements.upgrade(stateOwner);\n  }));\n};\nconst domParser = new globalThis.DOMParser();\nconst parseHtmlToText = text => text ? domParser.parseFromString(text, \"text/html\").body.textContent || text : text;\nconst stateMediator = {\n  mediaError: {\n    get(stateOwners, event) {\n      const {\n        media\n      } = stateOwners;\n      if ((event == null ? void 0 : event.type) === \"playing\") return;\n      return media == null ? void 0 : media.error;\n    },\n    mediaEvents: [\"emptied\", \"error\", \"playing\"]\n  },\n  mediaErrorCode: {\n    get(stateOwners, event) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if ((event == null ? void 0 : event.type) === \"playing\") return;\n      return (_a = media == null ? void 0 : media.error) == null ? void 0 : _a.code;\n    },\n    mediaEvents: [\"emptied\", \"error\", \"playing\"]\n  },\n  mediaErrorMessage: {\n    get(stateOwners, event) {\n      var _a, _b;\n      const {\n        media\n      } = stateOwners;\n      if ((event == null ? void 0 : event.type) === \"playing\") return;\n      return (_b = (_a = media == null ? void 0 : media.error) == null ? void 0 : _a.message) != null ? _b : \"\";\n    },\n    mediaEvents: [\"emptied\", \"error\", \"playing\"]\n  },\n  mediaWidth: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.videoWidth) != null ? _a : 0;\n    },\n    mediaEvents: [\"resize\"]\n  },\n  mediaHeight: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.videoHeight) != null ? _a : 0;\n    },\n    mediaEvents: [\"resize\"]\n  },\n  mediaPaused: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.paused) != null ? _a : true;\n    },\n    set(value, stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      if (value) {\n        media.pause();\n      } else {\n        (_a = media.play()) == null ? void 0 : _a.catch(() => {});\n      }\n    },\n    mediaEvents: [\"play\", \"playing\", \"pause\", \"emptied\"]\n  },\n  mediaHasPlayed: {\n    // We want to let the user know that the media started playing at any point (`media-has-played`).\n    // Since these propagators are all called when boostrapping state, let's verify this is\n    // a real playing event by checking that 1) there's media and 2) it isn't currently paused.\n    get(stateOwners, event) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return false;\n      if (!event) return !media.paused;\n      return event.type === \"playing\";\n    },\n    mediaEvents: [\"playing\", \"emptied\"]\n  },\n  mediaEnded: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.ended) != null ? _a : false;\n    },\n    mediaEvents: [\"seeked\", \"ended\", \"emptied\"]\n  },\n  mediaPlaybackRate: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.playbackRate) != null ? _a : 1;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      if (!Number.isFinite(+value)) return;\n      media.playbackRate = +value;\n    },\n    mediaEvents: [\"ratechange\", \"loadstart\"]\n  },\n  mediaMuted: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.muted) != null ? _a : false;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      try {\n        globalThis.localStorage.setItem(\"media-chrome-pref-muted\", value ? \"true\" : \"false\");\n      } catch (e) {\n        console.debug(\"Error setting muted pref\", e);\n      }\n      media.muted = value;\n    },\n    mediaEvents: [\"volumechange\"],\n    stateOwnersUpdateHandlers: [(handler, stateOwners) => {\n      const {\n        options: {\n          noMutedPref\n        }\n      } = stateOwners;\n      const {\n        media\n      } = stateOwners;\n      if (!media || media.muted || noMutedPref) return;\n      try {\n        const mutedPref = globalThis.localStorage.getItem(\"media-chrome-pref-muted\") === \"true\";\n        stateMediator.mediaMuted.set(mutedPref, stateOwners);\n        handler(mutedPref);\n      } catch (e) {\n        console.debug(\"Error getting muted pref\", e);\n      }\n    }]\n  },\n  mediaVolume: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.volume) != null ? _a : 1;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      try {\n        if (value == null) {\n          globalThis.localStorage.removeItem(\"media-chrome-pref-volume\");\n        } else {\n          globalThis.localStorage.setItem(\"media-chrome-pref-volume\", value.toString());\n        }\n      } catch (e) {\n        console.debug(\"Error setting volume pref\", e);\n      }\n      if (!Number.isFinite(+value)) return;\n      media.volume = +value;\n    },\n    mediaEvents: [\"volumechange\"],\n    stateOwnersUpdateHandlers: [(handler, stateOwners) => {\n      const {\n        options: {\n          noVolumePref\n        }\n      } = stateOwners;\n      if (noVolumePref) return;\n      try {\n        const {\n          media\n        } = stateOwners;\n        if (!media) return;\n        const volumePref = globalThis.localStorage.getItem(\"media-chrome-pref-volume\");\n        if (volumePref == null) return;\n        stateMediator.mediaVolume.set(+volumePref, stateOwners);\n        handler(+volumePref);\n      } catch (e) {\n        console.debug(\"Error getting volume pref\", e);\n      }\n    }]\n  },\n  // NOTE: Keeping this roughly equivalent to prior impl to reduce number of changes,\n  // however we may want to model \"derived\" state differently from \"primary\" state\n  // (in this case, derived === mediaVolumeLevel, primary === mediaMuted, mediaVolume) (CJP)\n  mediaVolumeLevel: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (typeof (media == null ? void 0 : media.volume) == \"undefined\") return \"high\";\n      if (media.muted || media.volume === 0) return \"off\";\n      if (media.volume < 0.5) return \"low\";\n      if (media.volume < 0.75) return \"medium\";\n      return \"high\";\n    },\n    mediaEvents: [\"volumechange\"]\n  },\n  mediaCurrentTime: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return (_a = media == null ? void 0 : media.currentTime) != null ? _a : 0;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media || !isValidNumber(value)) return;\n      media.currentTime = value;\n    },\n    mediaEvents: [\"timeupdate\", \"loadedmetadata\"]\n  },\n  mediaDuration: {\n    get(stateOwners) {\n      const {\n        media,\n        options: {\n          defaultDuration\n        } = {}\n      } = stateOwners;\n      if (defaultDuration && (!media || !media.duration || Number.isNaN(media.duration) || !Number.isFinite(media.duration))) {\n        return defaultDuration;\n      }\n      return Number.isFinite(media == null ? void 0 : media.duration) ? media.duration : Number.NaN;\n    },\n    mediaEvents: [\"durationchange\", \"loadedmetadata\", \"emptied\"]\n  },\n  mediaLoading: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      return (media == null ? void 0 : media.readyState) < 3;\n    },\n    mediaEvents: [\"waiting\", \"playing\", \"emptied\"]\n  },\n  mediaSeekable: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!((_a = media == null ? void 0 : media.seekable) == null ? void 0 : _a.length)) return void 0;\n      const start = media.seekable.start(0);\n      const end = media.seekable.end(media.seekable.length - 1);\n      if (!start && !end) return void 0;\n      return [Number(start.toFixed(3)), Number(end.toFixed(3))];\n    },\n    mediaEvents: [\"loadedmetadata\", \"emptied\", \"progress\", \"seekablechange\"]\n  },\n  mediaBuffered: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      const timeRanges = (_a = media == null ? void 0 : media.buffered) != null ? _a : [];\n      return Array.from(timeRanges).map((_, i) => [Number(timeRanges.start(i).toFixed(3)), Number(timeRanges.end(i).toFixed(3))]);\n    },\n    mediaEvents: [\"progress\", \"emptied\"]\n  },\n  mediaStreamType: {\n    get(stateOwners) {\n      const {\n        media,\n        options: {\n          defaultStreamType\n        } = {}\n      } = stateOwners;\n      const usedDefaultStreamType = [StreamTypes.LIVE, StreamTypes.ON_DEMAND].includes(defaultStreamType) ? defaultStreamType : void 0;\n      if (!media) return usedDefaultStreamType;\n      const {\n        streamType\n      } = media;\n      if (StreamTypeValues.includes(streamType)) {\n        if (streamType === StreamTypes.UNKNOWN) {\n          return usedDefaultStreamType;\n        }\n        return streamType;\n      }\n      const duration = media.duration;\n      if (duration === Infinity) {\n        return StreamTypes.LIVE;\n      } else if (Number.isFinite(duration)) {\n        return StreamTypes.ON_DEMAND;\n      }\n      return usedDefaultStreamType;\n    },\n    mediaEvents: [\"emptied\", \"durationchange\", \"loadedmetadata\", \"streamtypechange\"]\n  },\n  mediaTargetLiveWindow: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return Number.NaN;\n      const {\n        targetLiveWindow\n      } = media;\n      const streamType = stateMediator.mediaStreamType.get(stateOwners);\n      if ((targetLiveWindow == null || Number.isNaN(targetLiveWindow)) && streamType === StreamTypes.LIVE) {\n        return 0;\n      }\n      return targetLiveWindow;\n    },\n    mediaEvents: [\"emptied\", \"durationchange\", \"loadedmetadata\", \"streamtypechange\", \"targetlivewindowchange\"]\n  },\n  mediaTimeIsLive: {\n    get(stateOwners) {\n      const {\n        media,\n        // Default to 10 seconds\n        options: {\n          liveEdgeOffset = 10\n        } = {}\n      } = stateOwners;\n      if (!media) return false;\n      if (typeof media.liveEdgeStart === \"number\") {\n        if (Number.isNaN(media.liveEdgeStart)) return false;\n        return media.currentTime >= media.liveEdgeStart;\n      }\n      const live = stateMediator.mediaStreamType.get(stateOwners) === StreamTypes.LIVE;\n      if (!live) return false;\n      const seekable = media.seekable;\n      if (!seekable) return true;\n      if (!seekable.length) return false;\n      const liveEdgeStart = seekable.end(seekable.length - 1) - liveEdgeOffset;\n      return media.currentTime >= liveEdgeStart;\n    },\n    mediaEvents: [\"playing\", \"timeupdate\", \"progress\", \"waiting\", \"emptied\"]\n  },\n  // Text Tracks modeling\n  mediaSubtitlesList: {\n    get(stateOwners) {\n      return getSubtitleTracks(stateOwners).map(({\n        kind,\n        label,\n        language\n      }) => ({\n        kind,\n        label,\n        language\n      }));\n    },\n    mediaEvents: [\"loadstart\"],\n    textTracksEvents: [\"addtrack\", \"removetrack\"]\n  },\n  mediaSubtitlesShowing: {\n    get(stateOwners) {\n      return getShowingSubtitleTracks(stateOwners).map(({\n        kind,\n        label,\n        language\n      }) => ({\n        kind,\n        label,\n        language\n      }));\n    },\n    mediaEvents: [\"loadstart\"],\n    textTracksEvents: [\"addtrack\", \"removetrack\", \"change\"],\n    stateOwnersUpdateHandlers: [(_handler, stateOwners) => {\n      var _a, _b;\n      const {\n        media,\n        options\n      } = stateOwners;\n      if (!media) return;\n      const updateDefaultSubtitlesCallback = event => {\n        var _a2;\n        if (!options.defaultSubtitles) return;\n        const nonSubsEvent = event && ![TextTrackKinds.CAPTIONS, TextTrackKinds.SUBTITLES].includes(\n        // @ts-ignore\n        (_a2 = event == null ? void 0 : event.track) == null ? void 0 : _a2.kind);\n        if (nonSubsEvent) return;\n        toggleSubtitleTracks(stateOwners, true);\n      };\n      media.addEventListener(\"loadstart\", updateDefaultSubtitlesCallback);\n      (_a = media.textTracks) == null ? void 0 : _a.addEventListener(\"addtrack\", updateDefaultSubtitlesCallback);\n      (_b = media.textTracks) == null ? void 0 : _b.addEventListener(\"removetrack\", updateDefaultSubtitlesCallback);\n      return () => {\n        var _a2, _b2;\n        media.removeEventListener(\"loadstart\", updateDefaultSubtitlesCallback);\n        (_a2 = media.textTracks) == null ? void 0 : _a2.removeEventListener(\"addtrack\", updateDefaultSubtitlesCallback);\n        (_b2 = media.textTracks) == null ? void 0 : _b2.removeEventListener(\"removetrack\", updateDefaultSubtitlesCallback);\n      };\n    }]\n  },\n  mediaChaptersCues: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return [];\n      const [chaptersTrack] = getTextTracksList(media, {\n        kind: TextTrackKinds.CHAPTERS\n      });\n      return Array.from((_a = chaptersTrack == null ? void 0 : chaptersTrack.cues) != null ? _a : []).map(({\n        text,\n        startTime,\n        endTime\n      }) => ({\n        text: parseHtmlToText(text),\n        startTime,\n        endTime\n      }));\n    },\n    mediaEvents: [\"loadstart\", \"loadedmetadata\"],\n    textTracksEvents: [\"addtrack\", \"removetrack\", \"change\"],\n    stateOwnersUpdateHandlers: [(handler, stateOwners) => {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      const chaptersTrack = media.querySelector('track[kind=\"chapters\"][default][src]');\n      const shadowChaptersTrack = (_a = media.shadowRoot) == null ? void 0 : _a.querySelector(':is(video,audio) > track[kind=\"chapters\"][default][src]');\n      chaptersTrack == null ? void 0 : chaptersTrack.addEventListener(\"load\", handler);\n      shadowChaptersTrack == null ? void 0 : shadowChaptersTrack.addEventListener(\"load\", handler);\n      return () => {\n        chaptersTrack == null ? void 0 : chaptersTrack.removeEventListener(\"load\", handler);\n        shadowChaptersTrack == null ? void 0 : shadowChaptersTrack.removeEventListener(\"load\", handler);\n      };\n    }]\n  },\n  // Modeling state tied to root node\n  mediaIsPip: {\n    get(stateOwners) {\n      var _a, _b;\n      const {\n        media,\n        documentElement\n      } = stateOwners;\n      if (!media || !documentElement) return false;\n      if (!documentElement.pictureInPictureElement) return false;\n      if (documentElement.pictureInPictureElement === media) return true;\n      if (documentElement.pictureInPictureElement instanceof HTMLMediaElement) {\n        if (!((_a = media.localName) == null ? void 0 : _a.includes(\"-\"))) return false;\n        return containsComposedNode(media, documentElement.pictureInPictureElement);\n      }\n      if (documentElement.pictureInPictureElement.localName.includes(\"-\")) {\n        let currentRoot = documentElement.pictureInPictureElement.shadowRoot;\n        while (currentRoot == null ? void 0 : currentRoot.pictureInPictureElement) {\n          if (currentRoot.pictureInPictureElement === media) return true;\n          currentRoot = (_b = currentRoot.pictureInPictureElement) == null ? void 0 : _b.shadowRoot;\n        }\n      }\n      return false;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      if (value) {\n        if (!document.pictureInPictureEnabled) {\n          console.warn(\"MediaChrome: Picture-in-picture is not enabled\");\n          return;\n        }\n        if (!media.requestPictureInPicture) {\n          console.warn(\"MediaChrome: The current media does not support picture-in-picture\");\n          return;\n        }\n        const warnNotReady = () => {\n          console.warn(\"MediaChrome: The media is not ready for picture-in-picture. It must have a readyState > 0.\");\n        };\n        media.requestPictureInPicture().catch(err => {\n          if (err.code === 11) {\n            if (!media.src) {\n              console.warn(\"MediaChrome: The media is not ready for picture-in-picture. It must have a src set.\");\n              return;\n            }\n            if (media.readyState === 0 && media.preload === \"none\") {\n              const cleanup = () => {\n                media.removeEventListener(\"loadedmetadata\", tryPip);\n                media.preload = \"none\";\n              };\n              const tryPip = () => {\n                media.requestPictureInPicture().catch(warnNotReady);\n                cleanup();\n              };\n              media.addEventListener(\"loadedmetadata\", tryPip);\n              media.preload = \"metadata\";\n              setTimeout(() => {\n                if (media.readyState === 0) warnNotReady();\n                cleanup();\n              }, 1e3);\n            } else {\n              throw err;\n            }\n          } else {\n            throw err;\n          }\n        });\n      } else if (document.pictureInPictureElement) {\n        document.exitPictureInPicture();\n      }\n    },\n    mediaEvents: [\"enterpictureinpicture\", \"leavepictureinpicture\"]\n  },\n  mediaRenditionList: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return [...((_a = media == null ? void 0 : media.videoRenditions) != null ? _a : [])].map(videoRendition => ({\n        ...videoRendition\n      }));\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    videoRenditionsEvents: [\"addrendition\", \"removerendition\"]\n  },\n  /** @TODO Model this as a derived value? (CJP) */\n  mediaRenditionSelected: {\n    get(stateOwners) {\n      var _a, _b, _c;\n      const {\n        media\n      } = stateOwners;\n      return (_c = (_b = media == null ? void 0 : media.videoRenditions) == null ? void 0 : _b[(_a = media.videoRenditions) == null ? void 0 : _a.selectedIndex]) == null ? void 0 : _c.id;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!(media == null ? void 0 : media.videoRenditions)) {\n        console.warn(\"MediaController: Rendition selection not supported by this media.\");\n        return;\n      }\n      const renditionId = value;\n      const index = Array.prototype.findIndex.call(media.videoRenditions, r => r.id == renditionId);\n      if (media.videoRenditions.selectedIndex != index) {\n        media.videoRenditions.selectedIndex = index;\n      }\n    },\n    mediaEvents: [\"emptied\"],\n    videoRenditionsEvents: [\"addrendition\", \"removerendition\", \"change\"]\n  },\n  mediaAudioTrackList: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      return [...((_a = media == null ? void 0 : media.audioTracks) != null ? _a : [])];\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    audioTracksEvents: [\"addtrack\", \"removetrack\"]\n  },\n  mediaAudioTrackEnabled: {\n    get(stateOwners) {\n      var _a, _b;\n      const {\n        media\n      } = stateOwners;\n      return (_b = [...((_a = media == null ? void 0 : media.audioTracks) != null ? _a : [])].find(audioTrack => audioTrack.enabled)) == null ? void 0 : _b.id;\n    },\n    set(value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!(media == null ? void 0 : media.audioTracks)) {\n        console.warn(\"MediaChrome: Audio track selection not supported by this media.\");\n        return;\n      }\n      const audioTrackId = value;\n      for (const track of media.audioTracks) {\n        track.enabled = audioTrackId == track.id;\n      }\n    },\n    mediaEvents: [\"emptied\"],\n    audioTracksEvents: [\"addtrack\", \"removetrack\", \"change\"]\n  },\n  mediaIsFullscreen: {\n    get(stateOwners) {\n      return isFullscreen(stateOwners);\n    },\n    set(value, stateOwners) {\n      if (!value) {\n        exitFullscreen(stateOwners);\n      } else {\n        enterFullscreen(stateOwners);\n      }\n    },\n    // older Safari version may require webkit-specific events\n    rootEvents: [\"fullscreenchange\", \"webkitfullscreenchange\"],\n    // iOS requires webkit-specific events on the video.\n    mediaEvents: [\"webkitbeginfullscreen\", \"webkitendfullscreen\", \"webkitpresentationmodechanged\"]\n  },\n  mediaIsCasting: {\n    // Note this relies on a customized castable-video element.\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!(media == null ? void 0 : media.remote) || ((_a = media.remote) == null ? void 0 : _a.state) === \"disconnected\") return false;\n      return !!media.remote.state;\n    },\n    set(value, stateOwners) {\n      var _a, _b;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      if (value && ((_a = media.remote) == null ? void 0 : _a.state) !== \"disconnected\") return;\n      if (!value && ((_b = media.remote) == null ? void 0 : _b.state) !== \"connected\") return;\n      if (typeof media.remote.prompt !== \"function\") {\n        console.warn(\"MediaChrome: Casting is not supported in this environment\");\n        return;\n      }\n      media.remote.prompt().catch(() => {});\n    },\n    remoteEvents: [\"connect\", \"connecting\", \"disconnect\"]\n  },\n  // NOTE: Newly added state for tracking airplaying\n  mediaIsAirplaying: {\n    // NOTE: Cannot know if airplaying since Safari doesn't fully support HTMLMediaElement::remote yet (e.g. remote::state) (CJP)\n    get() {\n      return false;\n    },\n    set(_value, stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      if (!(media.webkitShowPlaybackTargetPicker && globalThis.WebKitPlaybackTargetAvailabilityEvent)) {\n        console.error(\"MediaChrome: received a request to select AirPlay but AirPlay is not supported in this environment\");\n        return;\n      }\n      media.webkitShowPlaybackTargetPicker();\n    },\n    mediaEvents: [\"webkitcurrentplaybacktargetiswirelesschanged\"]\n  },\n  mediaFullscreenUnavailable: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!fullscreenSupported || !hasFullscreenSupport(media)) return AvailabilityStates.UNSUPPORTED;\n      return void 0;\n    }\n  },\n  mediaPipUnavailable: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (!pipSupported || !hasPipSupport(media)) return AvailabilityStates.UNSUPPORTED;\n    }\n  },\n  mediaVolumeUnavailable: {\n    get(stateOwners) {\n      const {\n        media\n      } = stateOwners;\n      if (volumeSupported === false || (media == null ? void 0 : media.volume) == void 0) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      return void 0;\n    },\n    // NOTE: Slightly different impl here. Added generic support for\n    // \"stateOwnersUpdateHandlers\" since the original impl had to hack around\n    // race conditions. (CJP)\n    stateOwnersUpdateHandlers: [handler => {\n      if (volumeSupported == null) {\n        volumeSupportPromise.then(supported => handler(supported ? void 0 : AvailabilityStates.UNSUPPORTED));\n      }\n    }]\n  },\n  mediaCastUnavailable: {\n    // @ts-ignore\n    get(stateOwners, {\n      availability = \"not-available\"\n    } = {}) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!castSupported || !((_a = media == null ? void 0 : media.remote) == null ? void 0 : _a.state)) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      if (availability == null || availability === \"available\") return void 0;\n      return AvailabilityStates.UNAVAILABLE;\n    },\n    stateOwnersUpdateHandlers: [(handler, stateOwners) => {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      const remotePlaybackDisabled = media.disableRemotePlayback || media.hasAttribute(\"disableremoteplayback\");\n      if (!remotePlaybackDisabled) {\n        (_a = media == null ? void 0 : media.remote) == null ? void 0 : _a.watchAvailability(availabilityBool => {\n          const availability = availabilityBool ? \"available\" : \"not-available\";\n          handler({\n            availability\n          });\n        }).catch(error => {\n          if (error.name === \"NotSupportedError\") {\n            handler({\n              availability: null\n            });\n          } else {\n            handler({\n              availability: \"not-available\"\n            });\n          }\n        });\n      }\n      return () => {\n        var _a2;\n        (_a2 = media == null ? void 0 : media.remote) == null ? void 0 : _a2.cancelWatchAvailability().catch(() => {});\n      };\n    }]\n  },\n  mediaAirplayUnavailable: {\n    get(_stateOwners, event) {\n      if (!airplaySupported) return AvailabilityStates.UNSUPPORTED;\n      if ((event == null ? void 0 : event.availability) === \"not-available\") {\n        return AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    // NOTE: Keeping this event, as it's still the documented way of monitoring\n    // for AirPlay availability from Apple.\n    // See: https://developer.apple.com/documentation/webkitjs/adding_an_airplay_button_to_your_safari_media_controls#2940021 (CJP)\n    mediaEvents: [\"webkitplaybacktargetavailabilitychanged\"],\n    stateOwnersUpdateHandlers: [(handler, stateOwners) => {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!media) return;\n      const remotePlaybackDisabled = media.disableRemotePlayback || media.hasAttribute(\"disableremoteplayback\");\n      if (!remotePlaybackDisabled) {\n        (_a = media == null ? void 0 : media.remote) == null ? void 0 : _a.watchAvailability(availabilityBool => {\n          const availability = availabilityBool ? \"available\" : \"not-available\";\n          handler({\n            availability\n          });\n        }).catch(error => {\n          if (error.name === \"NotSupportedError\") {\n            handler({\n              availability: null\n            });\n          } else {\n            handler({\n              availability: \"not-available\"\n            });\n          }\n        });\n      }\n      return () => {\n        var _a2;\n        (_a2 = media == null ? void 0 : media.remote) == null ? void 0 : _a2.cancelWatchAvailability().catch(() => {});\n      };\n    }]\n  },\n  mediaRenditionUnavailable: {\n    get(stateOwners) {\n      var _a;\n      const {\n        media\n      } = stateOwners;\n      if (!(media == null ? void 0 : media.videoRenditions)) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      if (!((_a = media.videoRenditions) == null ? void 0 : _a.length)) {\n        return AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    videoRenditionsEvents: [\"addrendition\", \"removerendition\"]\n  },\n  mediaAudioTrackUnavailable: {\n    get(stateOwners) {\n      var _a, _b;\n      const {\n        media\n      } = stateOwners;\n      if (!(media == null ? void 0 : media.audioTracks)) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      if (((_b = (_a = media.audioTracks) == null ? void 0 : _a.length) != null ? _b : 0) <= 1) {\n        return AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    audioTracksEvents: [\"addtrack\", \"removetrack\"]\n  }\n};\nexport { prepareStateOwners, stateMediator, volumeSupportPromise };","map":{"version":3,"names":["document","globalThis","AvailabilityStates","StreamTypes","TextTrackKinds","containsComposedNode","enterFullscreen","exitFullscreen","isFullscreen","airplaySupported","castSupported","fullscreenSupported","hasFullscreenSupport","hasPipSupport","hasVolumeSupportAsync","pipSupported","getShowingSubtitleTracks","getSubtitleTracks","toggleSubtitleTracks","getTextTracksList","isValidNumber","StreamTypeValues","Object","values","volumeSupported","volumeSupportPromise","then","supported","prepareStateOwners","stateOwners","Promise","all","filter","x","map","stateOwner","HTMLElement","name","localName","includes","classDef","customElements","get","whenDefined","upgrade","domParser","DOMParser","parseHtmlToText","text","parseFromString","body","textContent","stateMediator","mediaError","event","media","type","error","mediaEvents","mediaErrorCode","_a","code","mediaErrorMessage","_b","message","mediaWidth","videoWidth","mediaHeight","videoHeight","mediaPaused","paused","set","value","pause","play","catch","mediaHasPlayed","mediaEnded","ended","mediaPlaybackRate","playbackRate","Number","isFinite","mediaMuted","muted","localStorage","setItem","e","console","debug","stateOwnersUpdateHandlers","handler","options","noMutedPref","mutedPref","getItem","mediaVolume","volume","removeItem","toString","noVolumePref","volumePref","mediaVolumeLevel","mediaCurrentTime","currentTime","mediaDuration","defaultDuration","duration","isNaN","NaN","mediaLoading","readyState","mediaSeekable","seekable","length","start","end","toFixed","mediaBuffered","timeRanges","buffered","Array","from","_","i","mediaStreamType","defaultStreamType","usedDefaultStreamType","LIVE","ON_DEMAND","streamType","UNKNOWN","Infinity","mediaTargetLiveWindow","targetLiveWindow","mediaTimeIsLive","liveEdgeOffset","liveEdgeStart","live","mediaSubtitlesList","kind","label","language","textTracksEvents","mediaSubtitlesShowing","_handler","updateDefaultSubtitlesCallback","_a2","defaultSubtitles","nonSubsEvent","CAPTIONS","SUBTITLES","track","addEventListener","textTracks","_b2","removeEventListener","mediaChaptersCues","chaptersTrack","CHAPTERS","cues","startTime","endTime","querySelector","shadowChaptersTrack","shadowRoot","mediaIsPip","documentElement","pictureInPictureElement","HTMLMediaElement","currentRoot","pictureInPictureEnabled","warn","requestPictureInPicture","warnNotReady","err","src","preload","cleanup","tryPip","setTimeout","exitPictureInPicture","mediaRenditionList","videoRenditions","videoRendition","videoRenditionsEvents","mediaRenditionSelected","_c","selectedIndex","id","renditionId","index","prototype","findIndex","call","r","mediaAudioTrackList","audioTracks","audioTracksEvents","mediaAudioTrackEnabled","find","audioTrack","enabled","audioTrackId","mediaIsFullscreen","rootEvents","mediaIsCasting","remote","state","prompt","remoteEvents","mediaIsAirplaying","_value","webkitShowPlaybackTargetPicker","WebKitPlaybackTargetAvailabilityEvent","mediaFullscreenUnavailable","UNSUPPORTED","mediaPipUnavailable","mediaVolumeUnavailable","mediaCastUnavailable","availability","UNAVAILABLE","remotePlaybackDisabled","disableRemotePlayback","hasAttribute","watchAvailability","availabilityBool","cancelWatchAvailability","mediaAirplayUnavailable","_stateOwners","mediaRenditionUnavailable","mediaAudioTrackUnavailable"],"sources":["/Users/kelaiyaparikh/projects/first-app/client/node_modules/media-chrome/dist/media-store/state-mediator.js"],"sourcesContent":["import { document, globalThis } from \"../utils/server-safe-globals.js\";\nimport {\n  AvailabilityStates,\n  StreamTypes,\n  TextTrackKinds\n} from \"../constants.js\";\nimport { containsComposedNode } from \"../utils/element-utils.js\";\nimport {\n  enterFullscreen,\n  exitFullscreen,\n  isFullscreen\n} from \"../utils/fullscreen-api.js\";\nimport {\n  airplaySupported,\n  castSupported,\n  fullscreenSupported,\n  hasFullscreenSupport,\n  hasPipSupport,\n  hasVolumeSupportAsync,\n  pipSupported\n} from \"../utils/platform-tests.js\";\nimport {\n  getShowingSubtitleTracks,\n  getSubtitleTracks,\n  toggleSubtitleTracks\n} from \"./util.js\";\nimport { getTextTracksList } from \"../utils/captions.js\";\nimport { isValidNumber } from \"../utils/utils.js\";\nconst StreamTypeValues = Object.values(StreamTypes);\nlet volumeSupported;\nconst volumeSupportPromise = hasVolumeSupportAsync().then((supported) => {\n  volumeSupported = supported;\n  return volumeSupported;\n});\nconst prepareStateOwners = async (...stateOwners) => {\n  await Promise.all(\n    stateOwners.filter((x) => x).map(async (stateOwner) => {\n      if (!(\"localName\" in stateOwner && stateOwner instanceof globalThis.HTMLElement)) {\n        return;\n      }\n      const name = stateOwner.localName;\n      if (!name.includes(\"-\"))\n        return;\n      const classDef = globalThis.customElements.get(name);\n      if (classDef && stateOwner instanceof classDef)\n        return;\n      await globalThis.customElements.whenDefined(name);\n      globalThis.customElements.upgrade(stateOwner);\n    })\n  );\n};\nconst domParser = new globalThis.DOMParser();\nconst parseHtmlToText = (text) => text ? domParser.parseFromString(text, \"text/html\").body.textContent || text : text;\nconst stateMediator = {\n  mediaError: {\n    get(stateOwners, event) {\n      const { media } = stateOwners;\n      if ((event == null ? void 0 : event.type) === \"playing\")\n        return;\n      return media == null ? void 0 : media.error;\n    },\n    mediaEvents: [\"emptied\", \"error\", \"playing\"]\n  },\n  mediaErrorCode: {\n    get(stateOwners, event) {\n      var _a;\n      const { media } = stateOwners;\n      if ((event == null ? void 0 : event.type) === \"playing\")\n        return;\n      return (_a = media == null ? void 0 : media.error) == null ? void 0 : _a.code;\n    },\n    mediaEvents: [\"emptied\", \"error\", \"playing\"]\n  },\n  mediaErrorMessage: {\n    get(stateOwners, event) {\n      var _a, _b;\n      const { media } = stateOwners;\n      if ((event == null ? void 0 : event.type) === \"playing\")\n        return;\n      return (_b = (_a = media == null ? void 0 : media.error) == null ? void 0 : _a.message) != null ? _b : \"\";\n    },\n    mediaEvents: [\"emptied\", \"error\", \"playing\"]\n  },\n  mediaWidth: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.videoWidth) != null ? _a : 0;\n    },\n    mediaEvents: [\"resize\"]\n  },\n  mediaHeight: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.videoHeight) != null ? _a : 0;\n    },\n    mediaEvents: [\"resize\"]\n  },\n  mediaPaused: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.paused) != null ? _a : true;\n    },\n    set(value, stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      if (!media)\n        return;\n      if (value) {\n        media.pause();\n      } else {\n        (_a = media.play()) == null ? void 0 : _a.catch(() => {\n        });\n      }\n    },\n    mediaEvents: [\"play\", \"playing\", \"pause\", \"emptied\"]\n  },\n  mediaHasPlayed: {\n    // We want to let the user know that the media started playing at any point (`media-has-played`).\n    // Since these propagators are all called when boostrapping state, let's verify this is\n    // a real playing event by checking that 1) there's media and 2) it isn't currently paused.\n    get(stateOwners, event) {\n      const { media } = stateOwners;\n      if (!media)\n        return false;\n      if (!event)\n        return !media.paused;\n      return event.type === \"playing\";\n    },\n    mediaEvents: [\"playing\", \"emptied\"]\n  },\n  mediaEnded: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.ended) != null ? _a : false;\n    },\n    mediaEvents: [\"seeked\", \"ended\", \"emptied\"]\n  },\n  mediaPlaybackRate: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.playbackRate) != null ? _a : 1;\n    },\n    set(value, stateOwners) {\n      const { media } = stateOwners;\n      if (!media)\n        return;\n      if (!Number.isFinite(+value))\n        return;\n      media.playbackRate = +value;\n    },\n    mediaEvents: [\"ratechange\", \"loadstart\"]\n  },\n  mediaMuted: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.muted) != null ? _a : false;\n    },\n    set(value, stateOwners) {\n      const { media } = stateOwners;\n      if (!media)\n        return;\n      try {\n        globalThis.localStorage.setItem(\n          \"media-chrome-pref-muted\",\n          value ? \"true\" : \"false\"\n        );\n      } catch (e) {\n        console.debug(\"Error setting muted pref\", e);\n      }\n      media.muted = value;\n    },\n    mediaEvents: [\"volumechange\"],\n    stateOwnersUpdateHandlers: [\n      (handler, stateOwners) => {\n        const {\n          options: { noMutedPref }\n        } = stateOwners;\n        const { media } = stateOwners;\n        if (!media || media.muted || noMutedPref)\n          return;\n        try {\n          const mutedPref = globalThis.localStorage.getItem(\"media-chrome-pref-muted\") === \"true\";\n          stateMediator.mediaMuted.set(mutedPref, stateOwners);\n          handler(mutedPref);\n        } catch (e) {\n          console.debug(\"Error getting muted pref\", e);\n        }\n      }\n    ]\n  },\n  mediaVolume: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.volume) != null ? _a : 1;\n    },\n    set(value, stateOwners) {\n      const { media } = stateOwners;\n      if (!media)\n        return;\n      try {\n        if (value == null) {\n          globalThis.localStorage.removeItem(\"media-chrome-pref-volume\");\n        } else {\n          globalThis.localStorage.setItem(\n            \"media-chrome-pref-volume\",\n            value.toString()\n          );\n        }\n      } catch (e) {\n        console.debug(\"Error setting volume pref\", e);\n      }\n      if (!Number.isFinite(+value))\n        return;\n      media.volume = +value;\n    },\n    mediaEvents: [\"volumechange\"],\n    stateOwnersUpdateHandlers: [\n      (handler, stateOwners) => {\n        const {\n          options: { noVolumePref }\n        } = stateOwners;\n        if (noVolumePref)\n          return;\n        try {\n          const { media } = stateOwners;\n          if (!media)\n            return;\n          const volumePref = globalThis.localStorage.getItem(\n            \"media-chrome-pref-volume\"\n          );\n          if (volumePref == null)\n            return;\n          stateMediator.mediaVolume.set(+volumePref, stateOwners);\n          handler(+volumePref);\n        } catch (e) {\n          console.debug(\"Error getting volume pref\", e);\n        }\n      }\n    ]\n  },\n  // NOTE: Keeping this roughly equivalent to prior impl to reduce number of changes,\n  // however we may want to model \"derived\" state differently from \"primary\" state\n  // (in this case, derived === mediaVolumeLevel, primary === mediaMuted, mediaVolume) (CJP)\n  mediaVolumeLevel: {\n    get(stateOwners) {\n      const { media } = stateOwners;\n      if (typeof (media == null ? void 0 : media.volume) == \"undefined\")\n        return \"high\";\n      if (media.muted || media.volume === 0)\n        return \"off\";\n      if (media.volume < 0.5)\n        return \"low\";\n      if (media.volume < 0.75)\n        return \"medium\";\n      return \"high\";\n    },\n    mediaEvents: [\"volumechange\"]\n  },\n  mediaCurrentTime: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return (_a = media == null ? void 0 : media.currentTime) != null ? _a : 0;\n    },\n    set(value, stateOwners) {\n      const { media } = stateOwners;\n      if (!media || !isValidNumber(value))\n        return;\n      media.currentTime = value;\n    },\n    mediaEvents: [\"timeupdate\", \"loadedmetadata\"]\n  },\n  mediaDuration: {\n    get(stateOwners) {\n      const { media, options: { defaultDuration } = {} } = stateOwners;\n      if (defaultDuration && (!media || !media.duration || Number.isNaN(media.duration) || !Number.isFinite(media.duration))) {\n        return defaultDuration;\n      }\n      return Number.isFinite(media == null ? void 0 : media.duration) ? media.duration : Number.NaN;\n    },\n    mediaEvents: [\"durationchange\", \"loadedmetadata\", \"emptied\"]\n  },\n  mediaLoading: {\n    get(stateOwners) {\n      const { media } = stateOwners;\n      return (media == null ? void 0 : media.readyState) < 3;\n    },\n    mediaEvents: [\"waiting\", \"playing\", \"emptied\"]\n  },\n  mediaSeekable: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      if (!((_a = media == null ? void 0 : media.seekable) == null ? void 0 : _a.length))\n        return void 0;\n      const start = media.seekable.start(0);\n      const end = media.seekable.end(media.seekable.length - 1);\n      if (!start && !end)\n        return void 0;\n      return [Number(start.toFixed(3)), Number(end.toFixed(3))];\n    },\n    mediaEvents: [\"loadedmetadata\", \"emptied\", \"progress\", \"seekablechange\"]\n  },\n  mediaBuffered: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      const timeRanges = (_a = media == null ? void 0 : media.buffered) != null ? _a : [];\n      return Array.from(timeRanges).map((_, i) => [\n        Number(timeRanges.start(i).toFixed(3)),\n        Number(timeRanges.end(i).toFixed(3))\n      ]);\n    },\n    mediaEvents: [\"progress\", \"emptied\"]\n  },\n  mediaStreamType: {\n    get(stateOwners) {\n      const { media, options: { defaultStreamType } = {} } = stateOwners;\n      const usedDefaultStreamType = [\n        StreamTypes.LIVE,\n        StreamTypes.ON_DEMAND\n      ].includes(defaultStreamType) ? defaultStreamType : void 0;\n      if (!media)\n        return usedDefaultStreamType;\n      const { streamType } = media;\n      if (StreamTypeValues.includes(streamType)) {\n        if (streamType === StreamTypes.UNKNOWN) {\n          return usedDefaultStreamType;\n        }\n        return streamType;\n      }\n      const duration = media.duration;\n      if (duration === Infinity) {\n        return StreamTypes.LIVE;\n      } else if (Number.isFinite(duration)) {\n        return StreamTypes.ON_DEMAND;\n      }\n      return usedDefaultStreamType;\n    },\n    mediaEvents: [\n      \"emptied\",\n      \"durationchange\",\n      \"loadedmetadata\",\n      \"streamtypechange\"\n    ]\n  },\n  mediaTargetLiveWindow: {\n    get(stateOwners) {\n      const { media } = stateOwners;\n      if (!media)\n        return Number.NaN;\n      const { targetLiveWindow } = media;\n      const streamType = stateMediator.mediaStreamType.get(stateOwners);\n      if ((targetLiveWindow == null || Number.isNaN(targetLiveWindow)) && streamType === StreamTypes.LIVE) {\n        return 0;\n      }\n      return targetLiveWindow;\n    },\n    mediaEvents: [\n      \"emptied\",\n      \"durationchange\",\n      \"loadedmetadata\",\n      \"streamtypechange\",\n      \"targetlivewindowchange\"\n    ]\n  },\n  mediaTimeIsLive: {\n    get(stateOwners) {\n      const {\n        media,\n        // Default to 10 seconds\n        options: { liveEdgeOffset = 10 } = {}\n      } = stateOwners;\n      if (!media)\n        return false;\n      if (typeof media.liveEdgeStart === \"number\") {\n        if (Number.isNaN(media.liveEdgeStart))\n          return false;\n        return media.currentTime >= media.liveEdgeStart;\n      }\n      const live = stateMediator.mediaStreamType.get(stateOwners) === StreamTypes.LIVE;\n      if (!live)\n        return false;\n      const seekable = media.seekable;\n      if (!seekable)\n        return true;\n      if (!seekable.length)\n        return false;\n      const liveEdgeStart = seekable.end(seekable.length - 1) - liveEdgeOffset;\n      return media.currentTime >= liveEdgeStart;\n    },\n    mediaEvents: [\"playing\", \"timeupdate\", \"progress\", \"waiting\", \"emptied\"]\n  },\n  // Text Tracks modeling\n  mediaSubtitlesList: {\n    get(stateOwners) {\n      return getSubtitleTracks(stateOwners).map(\n        ({ kind, label, language }) => ({ kind, label, language })\n      );\n    },\n    mediaEvents: [\"loadstart\"],\n    textTracksEvents: [\"addtrack\", \"removetrack\"]\n  },\n  mediaSubtitlesShowing: {\n    get(stateOwners) {\n      return getShowingSubtitleTracks(stateOwners).map(\n        ({ kind, label, language }) => ({ kind, label, language })\n      );\n    },\n    mediaEvents: [\"loadstart\"],\n    textTracksEvents: [\"addtrack\", \"removetrack\", \"change\"],\n    stateOwnersUpdateHandlers: [\n      (_handler, stateOwners) => {\n        var _a, _b;\n        const { media, options } = stateOwners;\n        if (!media)\n          return;\n        const updateDefaultSubtitlesCallback = (event) => {\n          var _a2;\n          if (!options.defaultSubtitles)\n            return;\n          const nonSubsEvent = event && ![TextTrackKinds.CAPTIONS, TextTrackKinds.SUBTITLES].includes(\n            // @ts-ignore\n            (_a2 = event == null ? void 0 : event.track) == null ? void 0 : _a2.kind\n          );\n          if (nonSubsEvent)\n            return;\n          toggleSubtitleTracks(stateOwners, true);\n        };\n        media.addEventListener(\n          \"loadstart\",\n          updateDefaultSubtitlesCallback\n        );\n        (_a = media.textTracks) == null ? void 0 : _a.addEventListener(\n          \"addtrack\",\n          updateDefaultSubtitlesCallback\n        );\n        (_b = media.textTracks) == null ? void 0 : _b.addEventListener(\n          \"removetrack\",\n          updateDefaultSubtitlesCallback\n        );\n        return () => {\n          var _a2, _b2;\n          media.removeEventListener(\n            \"loadstart\",\n            updateDefaultSubtitlesCallback\n          );\n          (_a2 = media.textTracks) == null ? void 0 : _a2.removeEventListener(\n            \"addtrack\",\n            updateDefaultSubtitlesCallback\n          );\n          (_b2 = media.textTracks) == null ? void 0 : _b2.removeEventListener(\n            \"removetrack\",\n            updateDefaultSubtitlesCallback\n          );\n        };\n      }\n    ]\n  },\n  mediaChaptersCues: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      if (!media)\n        return [];\n      const [chaptersTrack] = getTextTracksList(media, {\n        kind: TextTrackKinds.CHAPTERS\n      });\n      return Array.from((_a = chaptersTrack == null ? void 0 : chaptersTrack.cues) != null ? _a : []).map(\n        ({ text, startTime, endTime }) => ({\n          text: parseHtmlToText(text),\n          startTime,\n          endTime\n        })\n      );\n    },\n    mediaEvents: [\"loadstart\", \"loadedmetadata\"],\n    textTracksEvents: [\"addtrack\", \"removetrack\", \"change\"],\n    stateOwnersUpdateHandlers: [\n      (handler, stateOwners) => {\n        var _a;\n        const { media } = stateOwners;\n        if (!media)\n          return;\n        const chaptersTrack = media.querySelector(\n          'track[kind=\"chapters\"][default][src]'\n        );\n        const shadowChaptersTrack = (_a = media.shadowRoot) == null ? void 0 : _a.querySelector(\n          ':is(video,audio) > track[kind=\"chapters\"][default][src]'\n        );\n        chaptersTrack == null ? void 0 : chaptersTrack.addEventListener(\"load\", handler);\n        shadowChaptersTrack == null ? void 0 : shadowChaptersTrack.addEventListener(\"load\", handler);\n        return () => {\n          chaptersTrack == null ? void 0 : chaptersTrack.removeEventListener(\"load\", handler);\n          shadowChaptersTrack == null ? void 0 : shadowChaptersTrack.removeEventListener(\"load\", handler);\n        };\n      }\n    ]\n  },\n  // Modeling state tied to root node\n  mediaIsPip: {\n    get(stateOwners) {\n      var _a, _b;\n      const { media, documentElement } = stateOwners;\n      if (!media || !documentElement)\n        return false;\n      if (!documentElement.pictureInPictureElement)\n        return false;\n      if (documentElement.pictureInPictureElement === media)\n        return true;\n      if (documentElement.pictureInPictureElement instanceof HTMLMediaElement) {\n        if (!((_a = media.localName) == null ? void 0 : _a.includes(\"-\")))\n          return false;\n        return containsComposedNode(\n          media,\n          documentElement.pictureInPictureElement\n        );\n      }\n      if (documentElement.pictureInPictureElement.localName.includes(\"-\")) {\n        let currentRoot = documentElement.pictureInPictureElement.shadowRoot;\n        while (currentRoot == null ? void 0 : currentRoot.pictureInPictureElement) {\n          if (currentRoot.pictureInPictureElement === media)\n            return true;\n          currentRoot = (_b = currentRoot.pictureInPictureElement) == null ? void 0 : _b.shadowRoot;\n        }\n      }\n      return false;\n    },\n    set(value, stateOwners) {\n      const { media } = stateOwners;\n      if (!media)\n        return;\n      if (value) {\n        if (!document.pictureInPictureEnabled) {\n          console.warn(\"MediaChrome: Picture-in-picture is not enabled\");\n          return;\n        }\n        if (!media.requestPictureInPicture) {\n          console.warn(\n            \"MediaChrome: The current media does not support picture-in-picture\"\n          );\n          return;\n        }\n        const warnNotReady = () => {\n          console.warn(\n            \"MediaChrome: The media is not ready for picture-in-picture. It must have a readyState > 0.\"\n          );\n        };\n        media.requestPictureInPicture().catch((err) => {\n          if (err.code === 11) {\n            if (!media.src) {\n              console.warn(\n                \"MediaChrome: The media is not ready for picture-in-picture. It must have a src set.\"\n              );\n              return;\n            }\n            if (media.readyState === 0 && media.preload === \"none\") {\n              const cleanup = () => {\n                media.removeEventListener(\"loadedmetadata\", tryPip);\n                media.preload = \"none\";\n              };\n              const tryPip = () => {\n                media.requestPictureInPicture().catch(warnNotReady);\n                cleanup();\n              };\n              media.addEventListener(\"loadedmetadata\", tryPip);\n              media.preload = \"metadata\";\n              setTimeout(() => {\n                if (media.readyState === 0)\n                  warnNotReady();\n                cleanup();\n              }, 1e3);\n            } else {\n              throw err;\n            }\n          } else {\n            throw err;\n          }\n        });\n      } else if (document.pictureInPictureElement) {\n        document.exitPictureInPicture();\n      }\n    },\n    mediaEvents: [\"enterpictureinpicture\", \"leavepictureinpicture\"]\n  },\n  mediaRenditionList: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return [...(_a = media == null ? void 0 : media.videoRenditions) != null ? _a : []].map((videoRendition) => ({\n        ...videoRendition\n      }));\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    videoRenditionsEvents: [\"addrendition\", \"removerendition\"]\n  },\n  /** @TODO Model this as a derived value? (CJP) */\n  mediaRenditionSelected: {\n    get(stateOwners) {\n      var _a, _b, _c;\n      const { media } = stateOwners;\n      return (_c = (_b = media == null ? void 0 : media.videoRenditions) == null ? void 0 : _b[(_a = media.videoRenditions) == null ? void 0 : _a.selectedIndex]) == null ? void 0 : _c.id;\n    },\n    set(value, stateOwners) {\n      const { media } = stateOwners;\n      if (!(media == null ? void 0 : media.videoRenditions)) {\n        console.warn(\n          \"MediaController: Rendition selection not supported by this media.\"\n        );\n        return;\n      }\n      const renditionId = value;\n      const index = Array.prototype.findIndex.call(\n        media.videoRenditions,\n        (r) => r.id == renditionId\n      );\n      if (media.videoRenditions.selectedIndex != index) {\n        media.videoRenditions.selectedIndex = index;\n      }\n    },\n    mediaEvents: [\"emptied\"],\n    videoRenditionsEvents: [\"addrendition\", \"removerendition\", \"change\"]\n  },\n  mediaAudioTrackList: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      return [...(_a = media == null ? void 0 : media.audioTracks) != null ? _a : []];\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    audioTracksEvents: [\"addtrack\", \"removetrack\"]\n  },\n  mediaAudioTrackEnabled: {\n    get(stateOwners) {\n      var _a, _b;\n      const { media } = stateOwners;\n      return (_b = [...(_a = media == null ? void 0 : media.audioTracks) != null ? _a : []].find(\n        (audioTrack) => audioTrack.enabled\n      )) == null ? void 0 : _b.id;\n    },\n    set(value, stateOwners) {\n      const { media } = stateOwners;\n      if (!(media == null ? void 0 : media.audioTracks)) {\n        console.warn(\n          \"MediaChrome: Audio track selection not supported by this media.\"\n        );\n        return;\n      }\n      const audioTrackId = value;\n      for (const track of media.audioTracks) {\n        track.enabled = audioTrackId == track.id;\n      }\n    },\n    mediaEvents: [\"emptied\"],\n    audioTracksEvents: [\"addtrack\", \"removetrack\", \"change\"]\n  },\n  mediaIsFullscreen: {\n    get(stateOwners) {\n      return isFullscreen(stateOwners);\n    },\n    set(value, stateOwners) {\n      if (!value) {\n        exitFullscreen(stateOwners);\n      } else {\n        enterFullscreen(stateOwners);\n      }\n    },\n    // older Safari version may require webkit-specific events\n    rootEvents: [\"fullscreenchange\", \"webkitfullscreenchange\"],\n    // iOS requires webkit-specific events on the video.\n    mediaEvents: [\n      \"webkitbeginfullscreen\",\n      \"webkitendfullscreen\",\n      \"webkitpresentationmodechanged\"\n    ]\n  },\n  mediaIsCasting: {\n    // Note this relies on a customized castable-video element.\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      if (!(media == null ? void 0 : media.remote) || ((_a = media.remote) == null ? void 0 : _a.state) === \"disconnected\")\n        return false;\n      return !!media.remote.state;\n    },\n    set(value, stateOwners) {\n      var _a, _b;\n      const { media } = stateOwners;\n      if (!media)\n        return;\n      if (value && ((_a = media.remote) == null ? void 0 : _a.state) !== \"disconnected\")\n        return;\n      if (!value && ((_b = media.remote) == null ? void 0 : _b.state) !== \"connected\")\n        return;\n      if (typeof media.remote.prompt !== \"function\") {\n        console.warn(\n          \"MediaChrome: Casting is not supported in this environment\"\n        );\n        return;\n      }\n      media.remote.prompt().catch(() => {\n      });\n    },\n    remoteEvents: [\"connect\", \"connecting\", \"disconnect\"]\n  },\n  // NOTE: Newly added state for tracking airplaying\n  mediaIsAirplaying: {\n    // NOTE: Cannot know if airplaying since Safari doesn't fully support HTMLMediaElement::remote yet (e.g. remote::state) (CJP)\n    get() {\n      return false;\n    },\n    set(_value, stateOwners) {\n      const { media } = stateOwners;\n      if (!media)\n        return;\n      if (!(media.webkitShowPlaybackTargetPicker && globalThis.WebKitPlaybackTargetAvailabilityEvent)) {\n        console.error(\n          \"MediaChrome: received a request to select AirPlay but AirPlay is not supported in this environment\"\n        );\n        return;\n      }\n      media.webkitShowPlaybackTargetPicker();\n    },\n    mediaEvents: [\"webkitcurrentplaybacktargetiswirelesschanged\"]\n  },\n  mediaFullscreenUnavailable: {\n    get(stateOwners) {\n      const { media } = stateOwners;\n      if (!fullscreenSupported || !hasFullscreenSupport(media))\n        return AvailabilityStates.UNSUPPORTED;\n      return void 0;\n    }\n  },\n  mediaPipUnavailable: {\n    get(stateOwners) {\n      const { media } = stateOwners;\n      if (!pipSupported || !hasPipSupport(media))\n        return AvailabilityStates.UNSUPPORTED;\n    }\n  },\n  mediaVolumeUnavailable: {\n    get(stateOwners) {\n      const { media } = stateOwners;\n      if (volumeSupported === false || (media == null ? void 0 : media.volume) == void 0) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      return void 0;\n    },\n    // NOTE: Slightly different impl here. Added generic support for\n    // \"stateOwnersUpdateHandlers\" since the original impl had to hack around\n    // race conditions. (CJP)\n    stateOwnersUpdateHandlers: [\n      (handler) => {\n        if (volumeSupported == null) {\n          volumeSupportPromise.then(\n            (supported) => handler(supported ? void 0 : AvailabilityStates.UNSUPPORTED)\n          );\n        }\n      }\n    ]\n  },\n  mediaCastUnavailable: {\n    // @ts-ignore\n    get(stateOwners, { availability = \"not-available\" } = {}) {\n      var _a;\n      const { media } = stateOwners;\n      if (!castSupported || !((_a = media == null ? void 0 : media.remote) == null ? void 0 : _a.state)) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      if (availability == null || availability === \"available\")\n        return void 0;\n      return AvailabilityStates.UNAVAILABLE;\n    },\n    stateOwnersUpdateHandlers: [\n      (handler, stateOwners) => {\n        var _a;\n        const { media } = stateOwners;\n        if (!media)\n          return;\n        const remotePlaybackDisabled = media.disableRemotePlayback || media.hasAttribute(\"disableremoteplayback\");\n        if (!remotePlaybackDisabled) {\n          (_a = media == null ? void 0 : media.remote) == null ? void 0 : _a.watchAvailability((availabilityBool) => {\n            const availability = availabilityBool ? \"available\" : \"not-available\";\n            handler({ availability });\n          }).catch((error) => {\n            if (error.name === \"NotSupportedError\") {\n              handler({ availability: null });\n            } else {\n              handler({ availability: \"not-available\" });\n            }\n          });\n        }\n        return () => {\n          var _a2;\n          (_a2 = media == null ? void 0 : media.remote) == null ? void 0 : _a2.cancelWatchAvailability().catch(() => {\n          });\n        };\n      }\n    ]\n  },\n  mediaAirplayUnavailable: {\n    get(_stateOwners, event) {\n      if (!airplaySupported)\n        return AvailabilityStates.UNSUPPORTED;\n      if ((event == null ? void 0 : event.availability) === \"not-available\") {\n        return AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    // NOTE: Keeping this event, as it's still the documented way of monitoring\n    // for AirPlay availability from Apple.\n    // See: https://developer.apple.com/documentation/webkitjs/adding_an_airplay_button_to_your_safari_media_controls#2940021 (CJP)\n    mediaEvents: [\"webkitplaybacktargetavailabilitychanged\"],\n    stateOwnersUpdateHandlers: [\n      (handler, stateOwners) => {\n        var _a;\n        const { media } = stateOwners;\n        if (!media)\n          return;\n        const remotePlaybackDisabled = media.disableRemotePlayback || media.hasAttribute(\"disableremoteplayback\");\n        if (!remotePlaybackDisabled) {\n          (_a = media == null ? void 0 : media.remote) == null ? void 0 : _a.watchAvailability((availabilityBool) => {\n            const availability = availabilityBool ? \"available\" : \"not-available\";\n            handler({ availability });\n          }).catch((error) => {\n            if (error.name === \"NotSupportedError\") {\n              handler({ availability: null });\n            } else {\n              handler({ availability: \"not-available\" });\n            }\n          });\n        }\n        return () => {\n          var _a2;\n          (_a2 = media == null ? void 0 : media.remote) == null ? void 0 : _a2.cancelWatchAvailability().catch(() => {\n          });\n        };\n      }\n    ]\n  },\n  mediaRenditionUnavailable: {\n    get(stateOwners) {\n      var _a;\n      const { media } = stateOwners;\n      if (!(media == null ? void 0 : media.videoRenditions)) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      if (!((_a = media.videoRenditions) == null ? void 0 : _a.length)) {\n        return AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    videoRenditionsEvents: [\"addrendition\", \"removerendition\"]\n  },\n  mediaAudioTrackUnavailable: {\n    get(stateOwners) {\n      var _a, _b;\n      const { media } = stateOwners;\n      if (!(media == null ? void 0 : media.audioTracks)) {\n        return AvailabilityStates.UNSUPPORTED;\n      }\n      if (((_b = (_a = media.audioTracks) == null ? void 0 : _a.length) != null ? _b : 0) <= 1) {\n        return AvailabilityStates.UNAVAILABLE;\n      }\n      return void 0;\n    },\n    mediaEvents: [\"emptied\", \"loadstart\"],\n    audioTracksEvents: [\"addtrack\", \"removetrack\"]\n  }\n};\nexport {\n  prepareStateOwners,\n  stateMediator,\n  volumeSupportPromise\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}