{"ast":null,"code":"/* global chrome, cast */\nimport { privateProps, IterableWeakSet, InvalidStateError, NotSupportedError, onCastApiAvailable, castContext, currentSession, currentMedia, editTracksInfo, getMediaStatus, setCastOptions } from './castable-utils.js';\nconst remoteInstances = new IterableWeakSet();\nconst castElementRef = new WeakSet();\nlet cf;\nonCastApiAvailable(() => {\n  if (!globalThis.chrome?.cast?.isAvailable) {\n    // Useful to see in verbose logs if this shows undefined or false.\n    console.debug('chrome.cast.isAvailable', globalThis.chrome?.cast?.isAvailable);\n    return;\n  }\n  if (!cf) {\n    cf = cast.framework;\n    castContext().addEventListener(cf.CastContextEventType.CAST_STATE_CHANGED, e => {\n      remoteInstances.forEach(r => privateProps.get(r).onCastStateChanged?.(e));\n    });\n    castContext().addEventListener(cf.CastContextEventType.SESSION_STATE_CHANGED, e => {\n      remoteInstances.forEach(r => privateProps.get(r).onSessionStateChanged?.(e));\n    });\n    remoteInstances.forEach(r => privateProps.get(r).init?.());\n  }\n});\nlet remotePlaybackCallbackIdCount = 0;\n\n/**\n * Remote Playback shim for the Google cast SDK.\n * https://w3c.github.io/remote-playback/\n */\nexport class RemotePlayback extends EventTarget {\n  #media;\n  #isInit;\n  #remotePlayer;\n  #remoteListeners;\n  #state = 'disconnected';\n  #available = false;\n  #callbacks = new Set();\n  #callbackIds = new WeakMap();\n  constructor(media) {\n    super();\n    this.#media = media;\n    remoteInstances.add(this);\n    privateProps.set(this, {\n      init: () => this.#init(),\n      onCastStateChanged: () => this.#onCastStateChanged(),\n      onSessionStateChanged: () => this.#onSessionStateChanged(),\n      getCastPlayer: () => this.#castPlayer\n    });\n    this.#init();\n  }\n  get #castPlayer() {\n    if (castElementRef.has(this.#media)) return this.#remotePlayer;\n    return undefined;\n  }\n\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/RemotePlayback/state\n   * @return {'disconnected'|'connecting'|'connected'}\n   */\n  get state() {\n    return this.#state;\n  }\n  async watchAvailability(callback) {\n    if (this.#media.disableRemotePlayback) {\n      throw new InvalidStateError('disableRemotePlayback attribute is present.');\n    }\n    this.#callbackIds.set(callback, ++remotePlaybackCallbackIdCount);\n    this.#callbacks.add(callback);\n\n    // https://w3c.github.io/remote-playback/#getting-the-remote-playback-devices-availability-information\n    queueMicrotask(() => callback(this.#hasDevicesAvailable()));\n    return remotePlaybackCallbackIdCount;\n  }\n  async cancelWatchAvailability(callback) {\n    if (this.#media.disableRemotePlayback) {\n      throw new InvalidStateError('disableRemotePlayback attribute is present.');\n    }\n    if (callback) {\n      this.#callbacks.delete(callback);\n    } else {\n      this.#callbacks.clear();\n    }\n  }\n  async prompt() {\n    if (this.#media.disableRemotePlayback) {\n      throw new InvalidStateError('disableRemotePlayback attribute is present.');\n    }\n    if (!globalThis.chrome?.cast?.isAvailable) {\n      throw new NotSupportedError('The RemotePlayback API is disabled on this platform.');\n    }\n    const willDisconnect = castElementRef.has(this.#media);\n    castElementRef.add(this.#media);\n    setCastOptions(this.#media.castOptions);\n    Object.entries(this.#remoteListeners).forEach(([event, listener]) => {\n      this.#remotePlayer.controller.addEventListener(event, listener);\n    });\n    try {\n      // Open browser cast menu.\n      await castContext().requestSession();\n    } catch (err) {\n      // If there will be no disconnect, reset some state here.\n      if (!willDisconnect) {\n        castElementRef.delete(this.#media);\n      }\n\n      // Don't throw an error if disconnecting or cancelling.\n      if (err === 'cancel') {\n        return;\n      }\n      throw new Error(err);\n    }\n    privateProps.get(this.#media)?.loadOnPrompt?.();\n  }\n  #disconnect() {\n    if (!castElementRef.has(this.#media)) return;\n    Object.entries(this.#remoteListeners).forEach(([event, listener]) => {\n      this.#remotePlayer.controller.removeEventListener(event, listener);\n    });\n    castElementRef.delete(this.#media);\n\n    // isMuted is not in savedPlayerState. should we sync this back to local?\n    this.#media.muted = this.#remotePlayer.isMuted;\n    this.#media.currentTime = this.#remotePlayer.savedPlayerState.currentTime;\n    if (this.#remotePlayer.savedPlayerState.isPaused === false) {\n      this.#media.play();\n    }\n  }\n  #hasDevicesAvailable() {\n    // Cast state: NO_DEVICES_AVAILABLE, NOT_CONNECTED, CONNECTING, CONNECTED\n    // https://developers.google.com/cast/docs/reference/web_sender/cast.framework#.CastState\n    const castState = castContext()?.getCastState();\n    return castState && castState !== 'NO_DEVICES_AVAILABLE';\n  }\n  #onCastStateChanged() {\n    // Cast state: NO_DEVICES_AVAILABLE, NOT_CONNECTED, CONNECTING, CONNECTED\n    // https://developers.google.com/cast/docs/reference/web_sender/cast.framework#.CastState\n    const castState = castContext().getCastState();\n    if (castElementRef.has(this.#media)) {\n      if (castState === 'CONNECTING') {\n        this.#state = 'connecting';\n        this.dispatchEvent(new Event('connecting'));\n      }\n    }\n    if (!this.#available && castState?.includes('CONNECT')) {\n      this.#available = true;\n      for (let callback of this.#callbacks) callback(true);\n    } else if (this.#available && (!castState || castState === 'NO_DEVICES_AVAILABLE')) {\n      this.#available = false;\n      for (let callback of this.#callbacks) callback(false);\n    }\n  }\n  async #onSessionStateChanged() {\n    // Session states: NO_SESSION, SESSION_STARTING, SESSION_STARTED, SESSION_START_FAILED,\n    //                 SESSION_ENDING, SESSION_ENDED, SESSION_RESUMED\n    // https://developers.google.com/cast/docs/reference/web_sender/cast.framework#.SessionState\n\n    const {\n      SESSION_RESUMED\n    } = cf.SessionState;\n    if (castContext().getSessionState() === SESSION_RESUMED) {\n      /**\n       * Figure out if this was the video that started the resumed session.\n       * @TODO make this more specific than just checking against the video src!! (WL)\n       *\n       * If this video element can get the same unique id on each browser refresh\n       * it would be possible to pass this unique id w/ `LoadRequest.customData`\n       * and verify against currentMedia().customData below.\n       */\n      if (this.#media.castSrc === currentMedia()?.media.contentId) {\n        castElementRef.add(this.#media);\n        Object.entries(this.#remoteListeners).forEach(([event, listener]) => {\n          this.#remotePlayer.controller.addEventListener(event, listener);\n        });\n\n        /**\n         * There is cast framework resume session bug when you refresh the page a few\n         * times the this.#remotePlayer.currentTime will not be in sync with the receiver :(\n         * The below status request syncs it back up.\n         */\n        try {\n          await getMediaStatus(new chrome.cast.media.GetStatusRequest());\n        } catch (error) {\n          console.error(error);\n        }\n\n        // Dispatch the play, playing events manually to sync remote playing state.\n        this.#remoteListeners[cf.RemotePlayerEventType.IS_PAUSED_CHANGED]();\n        this.#remoteListeners[cf.RemotePlayerEventType.PLAYER_STATE_CHANGED]();\n      }\n    }\n  }\n  #init() {\n    if (!cf || this.#isInit) return;\n    this.#isInit = true;\n    setCastOptions(this.#media.castOptions);\n\n    /**\n     * @TODO add listeners for addtrack, removetrack (WL)\n     * This only has an impact on <track> with a `src` because these have to be\n     * loaded manually in the load() method. This will require a new load() call\n     * for each added/removed track w/ src.\n     */\n    this.#media.textTracks.addEventListener('change', () => this.#updateRemoteTextTrack());\n    this.#onCastStateChanged();\n    this.#remotePlayer = new cf.RemotePlayer();\n    new cf.RemotePlayerController(this.#remotePlayer);\n    this.#remoteListeners = {\n      [cf.RemotePlayerEventType.IS_CONNECTED_CHANGED]: ({\n        value\n      }) => {\n        if (value === true) {\n          this.#state = 'connected';\n          this.dispatchEvent(new Event('connect'));\n        } else {\n          this.#disconnect();\n          this.#state = 'disconnected';\n          this.dispatchEvent(new Event('disconnect'));\n        }\n      },\n      [cf.RemotePlayerEventType.DURATION_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('durationchange'));\n      },\n      [cf.RemotePlayerEventType.VOLUME_LEVEL_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('volumechange'));\n      },\n      [cf.RemotePlayerEventType.IS_MUTED_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('volumechange'));\n      },\n      [cf.RemotePlayerEventType.CURRENT_TIME_CHANGED]: () => {\n        if (!this.#castPlayer?.isMediaLoaded) return;\n        this.#media.dispatchEvent(new Event('timeupdate'));\n      },\n      [cf.RemotePlayerEventType.VIDEO_INFO_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('resize'));\n      },\n      [cf.RemotePlayerEventType.IS_PAUSED_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event(this.paused ? 'pause' : 'play'));\n      },\n      [cf.RemotePlayerEventType.PLAYER_STATE_CHANGED]: () => {\n        // Player states: IDLE, PLAYING, PAUSED, BUFFERING\n        // https://developers.google.com/cast/docs/reference/web_sender/chrome.cast.media#.PlayerState\n\n        // pause event is handled above.\n        if (this.#castPlayer?.playerState === chrome.cast.media.PlayerState.PAUSED) {\n          return;\n        }\n        this.#media.dispatchEvent(new Event({\n          [chrome.cast.media.PlayerState.PLAYING]: 'playing',\n          [chrome.cast.media.PlayerState.BUFFERING]: 'waiting',\n          [chrome.cast.media.PlayerState.IDLE]: 'emptied'\n        }[this.#castPlayer?.playerState]));\n      },\n      [cf.RemotePlayerEventType.IS_MEDIA_LOADED_CHANGED]: async () => {\n        if (!this.#castPlayer?.isMediaLoaded) return;\n\n        // mediaInfo is not immediately available due to a bug? wait one tick\n        await Promise.resolve();\n        this.#onRemoteMediaLoaded();\n      }\n    };\n  }\n  #onRemoteMediaLoaded() {\n    this.#updateRemoteTextTrack();\n  }\n  async #updateRemoteTextTrack() {\n    if (!this.#castPlayer) return;\n\n    // Get the tracks w/ trackId's that have been loaded; manually or via a playlist like a M3U8 or MPD.\n    const remoteTracks = this.#remotePlayer.mediaInfo?.tracks ?? [];\n    const remoteSubtitles = remoteTracks.filter(({\n      type\n    }) => type === chrome.cast.media.TrackType.TEXT);\n    const localSubtitles = [...this.#media.textTracks].filter(({\n      kind\n    }) => kind === 'subtitles' || kind === 'captions');\n\n    // Create a new array from the local subs w/ the trackId's from the remote subs.\n    const subtitles = remoteSubtitles.map(({\n      language,\n      name,\n      trackId\n    }) => {\n      // Find the corresponding local text track and assign the trackId.\n      const {\n        mode\n      } = localSubtitles.find(local => local.language === language && local.label === name) ?? {};\n      if (mode) return {\n        mode,\n        trackId\n      };\n      return false;\n    }).filter(Boolean);\n    const hiddenSubtitles = subtitles.filter(({\n      mode\n    }) => mode !== 'showing');\n    const hiddenTrackIds = hiddenSubtitles.map(({\n      trackId\n    }) => trackId);\n    const showingSubtitle = subtitles.find(({\n      mode\n    }) => mode === 'showing');\n\n    // Note this could also include audio or video tracks, diff against local state.\n    const activeTrackIds = currentSession()?.getSessionObj().media[0]?.activeTrackIds ?? [];\n    let requestTrackIds = activeTrackIds;\n    if (activeTrackIds.length) {\n      // Filter out all local hidden subtitle trackId's.\n      requestTrackIds = requestTrackIds.filter(id => !hiddenTrackIds.includes(id));\n    }\n    if (showingSubtitle?.trackId) {\n      requestTrackIds = [...requestTrackIds, showingSubtitle.trackId];\n    }\n\n    // Remove duplicate ids.\n    requestTrackIds = [...new Set(requestTrackIds)];\n    const arrayEquals = (a, b) => a.length === b.length && a.every(a => b.includes(a));\n    if (!arrayEquals(activeTrackIds, requestTrackIds)) {\n      try {\n        const request = new chrome.cast.media.EditTracksInfoRequest(requestTrackIds);\n        await editTracksInfo(request);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n  }\n}","map":{"version":3,"names":["privateProps","IterableWeakSet","InvalidStateError","NotSupportedError","onCastApiAvailable","castContext","currentSession","currentMedia","editTracksInfo","getMediaStatus","setCastOptions","remoteInstances","castElementRef","WeakSet","cf","globalThis","chrome","cast","isAvailable","console","debug","framework","addEventListener","CastContextEventType","CAST_STATE_CHANGED","e","forEach","r","get","onCastStateChanged","SESSION_STATE_CHANGED","onSessionStateChanged","init","remotePlaybackCallbackIdCount","RemotePlayback","EventTarget","media","isInit","remotePlayer","remoteListeners","state","available","callbacks","Set","callbackIds","WeakMap","constructor","add","set","getCastPlayer","castPlayer","#castPlayer","has","undefined","watchAvailability","callback","disableRemotePlayback","queueMicrotask","hasDevicesAvailable","cancelWatchAvailability","delete","clear","prompt","willDisconnect","castOptions","Object","entries","event","listener","controller","requestSession","err","Error","loadOnPrompt","disconnect","#disconnect","removeEventListener","muted","isMuted","currentTime","savedPlayerState","isPaused","play","#hasDevicesAvailable","castState","getCastState","#onCastStateChanged","dispatchEvent","Event","includes","#onSessionStateChanged","SESSION_RESUMED","SessionState","getSessionState","castSrc","contentId","GetStatusRequest","error","RemotePlayerEventType","IS_PAUSED_CHANGED","PLAYER_STATE_CHANGED","#init","textTracks","updateRemoteTextTrack","RemotePlayer","RemotePlayerController","IS_CONNECTED_CHANGED","value","DURATION_CHANGED","VOLUME_LEVEL_CHANGED","IS_MUTED_CHANGED","CURRENT_TIME_CHANGED","isMediaLoaded","VIDEO_INFO_CHANGED","paused","playerState","PlayerState","PAUSED","PLAYING","BUFFERING","IDLE","IS_MEDIA_LOADED_CHANGED","Promise","resolve","onRemoteMediaLoaded","#onRemoteMediaLoaded","#updateRemoteTextTrack","remoteTracks","mediaInfo","tracks","remoteSubtitles","filter","type","TrackType","TEXT","localSubtitles","kind","subtitles","map","language","name","trackId","mode","find","local","label","Boolean","hiddenSubtitles","hiddenTrackIds","showingSubtitle","activeTrackIds","getSessionObj","requestTrackIds","length","id","arrayEquals","a","b","every","request","EditTracksInfoRequest"],"sources":["/Users/kelaiyaparikh/projects/first-app/client/node_modules/castable-video/castable-remote-playback.js"],"sourcesContent":["/* global chrome, cast */\nimport {\n  privateProps,\n  IterableWeakSet,\n  InvalidStateError,\n  NotSupportedError,\n  onCastApiAvailable,\n  castContext,\n  currentSession,\n  currentMedia,\n  editTracksInfo,\n  getMediaStatus,\n  setCastOptions\n} from './castable-utils.js';\n\nconst remoteInstances = new IterableWeakSet();\nconst castElementRef = new WeakSet();\n\nlet cf;\n\nonCastApiAvailable(() => {\n  if (!globalThis.chrome?.cast?.isAvailable) {\n    // Useful to see in verbose logs if this shows undefined or false.\n    console.debug('chrome.cast.isAvailable', globalThis.chrome?.cast?.isAvailable);\n    return;\n  }\n\n  if (!cf) {\n    cf = cast.framework;\n\n    castContext().addEventListener(cf.CastContextEventType.CAST_STATE_CHANGED, (e) => {\n      remoteInstances.forEach((r) => privateProps.get(r).onCastStateChanged?.(e));\n    });\n\n    castContext().addEventListener(cf.CastContextEventType.SESSION_STATE_CHANGED, (e) => {\n      remoteInstances.forEach((r) => privateProps.get(r).onSessionStateChanged?.(e));\n    });\n\n    remoteInstances.forEach((r) => privateProps.get(r).init?.());\n  }\n});\n\n\nlet remotePlaybackCallbackIdCount = 0;\n\n/**\n * Remote Playback shim for the Google cast SDK.\n * https://w3c.github.io/remote-playback/\n */\nexport class RemotePlayback extends EventTarget {\n  #media;\n  #isInit;\n  #remotePlayer;\n  #remoteListeners;\n  #state = 'disconnected';\n  #available = false;\n  #callbacks = new Set();\n  #callbackIds = new WeakMap();\n\n  constructor(media) {\n    super();\n\n    this.#media = media;\n\n    remoteInstances.add(this);\n    privateProps.set(this, {\n      init: () => this.#init(),\n      onCastStateChanged: () => this.#onCastStateChanged(),\n      onSessionStateChanged: () => this.#onSessionStateChanged(),\n      getCastPlayer: () => this.#castPlayer,\n    });\n\n    this.#init();\n  }\n\n  get #castPlayer() {\n    if (castElementRef.has(this.#media)) return this.#remotePlayer;\n    return undefined;\n  }\n\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/RemotePlayback/state\n   * @return {'disconnected'|'connecting'|'connected'}\n   */\n  get state() {\n    return this.#state;\n  }\n\n  async watchAvailability(callback) {\n    if (this.#media.disableRemotePlayback) {\n      throw new InvalidStateError('disableRemotePlayback attribute is present.');\n    }\n\n    this.#callbackIds.set(callback, ++remotePlaybackCallbackIdCount);\n    this.#callbacks.add(callback);\n\n    // https://w3c.github.io/remote-playback/#getting-the-remote-playback-devices-availability-information\n    queueMicrotask(() => callback(this.#hasDevicesAvailable()));\n\n    return remotePlaybackCallbackIdCount;\n  }\n\n  async cancelWatchAvailability(callback) {\n    if (this.#media.disableRemotePlayback) {\n      throw new InvalidStateError('disableRemotePlayback attribute is present.');\n    }\n\n    if (callback) {\n      this.#callbacks.delete(callback);\n    } else {\n      this.#callbacks.clear();\n    }\n  }\n\n  async prompt() {\n    if (this.#media.disableRemotePlayback) {\n      throw new InvalidStateError('disableRemotePlayback attribute is present.');\n    }\n\n    if (!globalThis.chrome?.cast?.isAvailable) {\n      throw new NotSupportedError('The RemotePlayback API is disabled on this platform.');\n    }\n\n    const willDisconnect = castElementRef.has(this.#media);\n    castElementRef.add(this.#media);\n\n    setCastOptions(this.#media.castOptions);\n\n    Object.entries(this.#remoteListeners).forEach(([event, listener]) => {\n      this.#remotePlayer.controller.addEventListener(event, listener);\n    });\n\n    try {\n      // Open browser cast menu.\n      await castContext().requestSession();\n    } catch (err) {\n      // If there will be no disconnect, reset some state here.\n      if (!willDisconnect) {\n        castElementRef.delete(this.#media);\n      }\n\n      // Don't throw an error if disconnecting or cancelling.\n      if (err === 'cancel') {\n        return;\n      }\n\n      throw new Error(err);\n    }\n\n    privateProps.get(this.#media)?.loadOnPrompt?.();\n  }\n\n  #disconnect() {\n    if (!castElementRef.has(this.#media)) return;\n\n    Object.entries(this.#remoteListeners).forEach(([event, listener]) => {\n      this.#remotePlayer.controller.removeEventListener(event, listener);\n    });\n\n    castElementRef.delete(this.#media);\n\n    // isMuted is not in savedPlayerState. should we sync this back to local?\n    this.#media.muted = this.#remotePlayer.isMuted;\n    this.#media.currentTime = this.#remotePlayer.savedPlayerState.currentTime;\n    if (this.#remotePlayer.savedPlayerState.isPaused === false) {\n      this.#media.play();\n    }\n  }\n\n  #hasDevicesAvailable() {\n    // Cast state: NO_DEVICES_AVAILABLE, NOT_CONNECTED, CONNECTING, CONNECTED\n    // https://developers.google.com/cast/docs/reference/web_sender/cast.framework#.CastState\n    const castState = castContext()?.getCastState();\n    return castState && castState !== 'NO_DEVICES_AVAILABLE';\n  }\n\n  #onCastStateChanged() {\n    // Cast state: NO_DEVICES_AVAILABLE, NOT_CONNECTED, CONNECTING, CONNECTED\n    // https://developers.google.com/cast/docs/reference/web_sender/cast.framework#.CastState\n    const castState = castContext().getCastState();\n\n    if (castElementRef.has(this.#media)) {\n      if (castState === 'CONNECTING') {\n        this.#state = 'connecting';\n        this.dispatchEvent(new Event('connecting'));\n      }\n    }\n\n    if (!this.#available && castState?.includes('CONNECT')) {\n      this.#available = true;\n      for (let callback of this.#callbacks) callback(true);\n    }\n    else if (this.#available && (!castState || castState === 'NO_DEVICES_AVAILABLE')) {\n      this.#available = false;\n      for (let callback of this.#callbacks) callback(false);\n    }\n  }\n\n  async #onSessionStateChanged() {\n    // Session states: NO_SESSION, SESSION_STARTING, SESSION_STARTED, SESSION_START_FAILED,\n    //                 SESSION_ENDING, SESSION_ENDED, SESSION_RESUMED\n    // https://developers.google.com/cast/docs/reference/web_sender/cast.framework#.SessionState\n\n    const { SESSION_RESUMED } = cf.SessionState;\n    if (castContext().getSessionState() === SESSION_RESUMED) {\n      /**\n       * Figure out if this was the video that started the resumed session.\n       * @TODO make this more specific than just checking against the video src!! (WL)\n       *\n       * If this video element can get the same unique id on each browser refresh\n       * it would be possible to pass this unique id w/ `LoadRequest.customData`\n       * and verify against currentMedia().customData below.\n       */\n      if (this.#media.castSrc === currentMedia()?.media.contentId) {\n        castElementRef.add(this.#media);\n\n        Object.entries(this.#remoteListeners).forEach(([event, listener]) => {\n          this.#remotePlayer.controller.addEventListener(event, listener);\n        });\n\n        /**\n         * There is cast framework resume session bug when you refresh the page a few\n         * times the this.#remotePlayer.currentTime will not be in sync with the receiver :(\n         * The below status request syncs it back up.\n         */\n        try {\n          await getMediaStatus(new chrome.cast.media.GetStatusRequest());\n        } catch (error) {\n          console.error(error);\n        }\n\n        // Dispatch the play, playing events manually to sync remote playing state.\n        this.#remoteListeners[cf.RemotePlayerEventType.IS_PAUSED_CHANGED]();\n        this.#remoteListeners[cf.RemotePlayerEventType.PLAYER_STATE_CHANGED]();\n      }\n    }\n  }\n\n  #init() {\n    if (!cf || this.#isInit) return;\n    this.#isInit = true;\n\n    setCastOptions(this.#media.castOptions);\n\n    /**\n     * @TODO add listeners for addtrack, removetrack (WL)\n     * This only has an impact on <track> with a `src` because these have to be\n     * loaded manually in the load() method. This will require a new load() call\n     * for each added/removed track w/ src.\n     */\n    this.#media.textTracks.addEventListener('change', () => this.#updateRemoteTextTrack());\n\n    this.#onCastStateChanged();\n\n    this.#remotePlayer = new cf.RemotePlayer();\n    new cf.RemotePlayerController(this.#remotePlayer);\n\n    this.#remoteListeners = {\n      [cf.RemotePlayerEventType.IS_CONNECTED_CHANGED]: ({ value }) => {\n        if (value === true) {\n          this.#state = 'connected';\n          this.dispatchEvent(new Event('connect'));\n        } else {\n          this.#disconnect();\n          this.#state = 'disconnected';\n          this.dispatchEvent(new Event('disconnect'));\n        }\n      },\n      [cf.RemotePlayerEventType.DURATION_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('durationchange'));\n      },\n      [cf.RemotePlayerEventType.VOLUME_LEVEL_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('volumechange'));\n      },\n      [cf.RemotePlayerEventType.IS_MUTED_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('volumechange'));\n      },\n      [cf.RemotePlayerEventType.CURRENT_TIME_CHANGED]: () => {\n        if (!this.#castPlayer?.isMediaLoaded) return;\n        this.#media.dispatchEvent(new Event('timeupdate'));\n      },\n      [cf.RemotePlayerEventType.VIDEO_INFO_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event('resize'));\n      },\n      [cf.RemotePlayerEventType.IS_PAUSED_CHANGED]: () => {\n        this.#media.dispatchEvent(new Event(this.paused ? 'pause' : 'play'));\n      },\n      [cf.RemotePlayerEventType.PLAYER_STATE_CHANGED]: () => {\n        // Player states: IDLE, PLAYING, PAUSED, BUFFERING\n        // https://developers.google.com/cast/docs/reference/web_sender/chrome.cast.media#.PlayerState\n\n        // pause event is handled above.\n        if (this.#castPlayer?.playerState === chrome.cast.media.PlayerState.PAUSED) {\n          return;\n        }\n\n        this.#media.dispatchEvent(\n          new Event(\n            {\n              [chrome.cast.media.PlayerState.PLAYING]: 'playing',\n              [chrome.cast.media.PlayerState.BUFFERING]: 'waiting',\n              [chrome.cast.media.PlayerState.IDLE]: 'emptied',\n            }[this.#castPlayer?.playerState]\n          )\n        );\n      },\n      [cf.RemotePlayerEventType.IS_MEDIA_LOADED_CHANGED]: async () => {\n        if (!this.#castPlayer?.isMediaLoaded) return;\n\n        // mediaInfo is not immediately available due to a bug? wait one tick\n        await Promise.resolve();\n        this.#onRemoteMediaLoaded();\n      },\n    };\n  }\n\n  #onRemoteMediaLoaded() {\n    this.#updateRemoteTextTrack();\n  }\n\n  async #updateRemoteTextTrack() {\n    if (!this.#castPlayer) return;\n\n    // Get the tracks w/ trackId's that have been loaded; manually or via a playlist like a M3U8 or MPD.\n    const remoteTracks = this.#remotePlayer.mediaInfo?.tracks ?? [];\n    const remoteSubtitles = remoteTracks.filter(\n      ({ type }) => type === chrome.cast.media.TrackType.TEXT\n    );\n\n    const localSubtitles = [...this.#media.textTracks].filter(\n      ({ kind }) => kind === 'subtitles' || kind === 'captions'\n    );\n\n    // Create a new array from the local subs w/ the trackId's from the remote subs.\n    const subtitles = remoteSubtitles\n      .map(({ language, name, trackId }) => {\n        // Find the corresponding local text track and assign the trackId.\n        const { mode } =\n          localSubtitles.find(\n            (local) => local.language === language && local.label === name\n          ) ?? {};\n        if (mode) return { mode, trackId };\n        return false;\n      })\n      .filter(Boolean);\n\n    const hiddenSubtitles = subtitles.filter(\n      ({ mode }) => mode !== 'showing'\n    );\n    const hiddenTrackIds = hiddenSubtitles.map(({ trackId }) => trackId);\n    const showingSubtitle = subtitles.find(({ mode }) => mode === 'showing');\n\n    // Note this could also include audio or video tracks, diff against local state.\n    const activeTrackIds =\n      currentSession()?.getSessionObj().media[0]\n        ?.activeTrackIds ?? [];\n    let requestTrackIds = activeTrackIds;\n\n    if (activeTrackIds.length) {\n      // Filter out all local hidden subtitle trackId's.\n      requestTrackIds = requestTrackIds.filter(\n        (id) => !hiddenTrackIds.includes(id)\n      );\n    }\n\n    if (showingSubtitle?.trackId) {\n      requestTrackIds = [...requestTrackIds, showingSubtitle.trackId];\n    }\n\n    // Remove duplicate ids.\n    requestTrackIds = [...new Set(requestTrackIds)];\n\n    const arrayEquals = (a, b) =>\n      a.length === b.length && a.every((a) => b.includes(a));\n    if (!arrayEquals(activeTrackIds, requestTrackIds)) {\n      try {\n        const request = new chrome.cast.media.EditTracksInfoRequest(\n          requestTrackIds\n        );\n        await editTracksInfo(request);\n      } catch (error) {\n        console.error(error);\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}